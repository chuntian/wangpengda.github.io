<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[2018年终总结]]></title>
    <url>%2F2019%2F02%2F02%2F2018%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[&#8195;&#8195;今天是2019年2月2号，农历腊月二十八，办公室里的同事已经寥寥无几，我还坚守在岗位上，我跟我媳妇戏言，是为了对得起我的敬业福啊，哈哈。转眼2018年就剩2天了，回顾过去一整年，我对自己的评价是不成功的。 过去的2018&#8195;&#8195;过去的一年，工作上对于我来说最大的事情，应该是换了个工作。在原来单位工作了6年，从一个最基层的程序员，做到了产品线经理，从技术和业务的积累上，基本上得到了上上下下的认可，年度优秀员工和年度优秀团队也都感受过。在个人情感上，6年的时间肯定有很多的感动和心酸在里边，谈不上爱，当然肯定没有恨，哈哈，只是在个人发展瓶颈和生活矛盾上难以处理，与其纠结，不如选择急流勇退。 &#8195;&#8195;这一年，在原单位，兼职过产品经理，做产品规划、产品定位、产品设计；兼职过需求和设计，写需求说明、画原型；兼职过架构师，规划系统架构、规划产品开发角色；兼职过开发经理，核心代码编写、系统开发管控；兼职过售前，ppt制作、产品宣讲、写标书；兼职过售后，运维沟通、邮件回复；做过产品线经理，产品线日常工作管理，其实就是汇报、审批的一些杂事。怎么样？是不是异常丰富？有的人会说，你可以啊，啥都能干啊。可是我觉得，说不好听就是有点不务正业，因为职位做得多，但是有限的时间内，是没办法做精的。当然，我还是要感谢能给我接触这么多事情的机会。 &#8195;&#8195;在新单位，由于来的时间并不长，虽然有相关的业务经验，但是每个公司在其日积月累的发展中，都会有其自己的独特性，所以在新单位的2018年总结中，工作相关我就不说太多了。但是比较让我庆幸的是，公司安排了有丰富工作经验，并且是今年年度优秀员工的老郭（此处应该有照片😄，带美颜那种）来带我，让我能够快速的学习到公司业务和了解公司相关情况，很是感谢。 未来的2019&#8195;&#8195;即将到来的2019年，是个怎样的一年，难以预测，资本寒冬是否会随着即将过去的2018年一样成为历史，还难以评定，所以，静观其变吧。不管怎样，新的一年应该有个新的气象，也学学当下流行的，立几个flag吧。 &#8195;&#8195;1、工作突破。自从参加工作以来，经历过的公司，我都力争做到公司里边各级领导和员工的认可，事实上，我也都做到了。所以，在新的单位，我有信心，同时我也做好了准备。 &#8195;&#8195;2、自我提升。所谓活到老，学到老,这是千古名训啊，不能忘。可能随着年龄的增长，或者是工作增多的原因，似乎变的越来越懒惰，这是非常不可取的。新的一年，技术业务和管理上，准备多读几本书，多做一些实践。 &#8195;&#8195;3、锻炼身体。身体越来越差了，体检好几个指标有问题，虽然问题不大，但是身体确实大不如前是事实。有时候上公交，挤不过老太太，真是挺尴尬啊。 &#8195;&#8195;4、来场旅游。跟我媳妇结婚一年多了，还没带她出去玩过。2019年，必须带她到除秦皇岛之外的其他地方，来一场说走就走的旅行。去他娘的没时间，去他娘的人民币，去她娘的那么多去她娘的… &#8195;&#8195;5、生个孩子玩玩。此处省略一万字。 结语&#8195;&#8195;过去的一年已经是历史，是好是坏也不能改变，新的一年，努力奔跑，只为追上曾经被家人寄予厚望的自己。]]></content>
      <categories>
        <category>人生感悟</category>
      </categories>
      <tags>
        <tag>年终总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[趣学算法(2)--贪心算法]]></title>
    <url>%2F2019%2F02%2F02%2F%E8%B6%A3%E5%AD%A6%E7%AE%97%E6%B3%95-2-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[&#8195;&#8195;接着算法系列，今天说说贪心算法。贪心这词一般说起来，感觉是个贬义词。但是现实生活中，谁有没有点贪心呢？比如两个苹果让你选，甜度相同，长相相同的情况下，你肯定会先挑大的；菜市场买菜，两家菜完全一样，你肯定挑其中更便宜的；男女双方择偶标准，是美优先？还是富优先？还是学历优先？不管怎样，你心里肯定会先排个序。这些案例从不同角度不同层面展现了我们在日常生活中，解决问题的方式方法，不得不说，大千世界各种理论都是源于生活，然后又应用的生活中去的。贪心算法，基本也是这个意思，书上的解释是迭代求局部最优解，我的解释我觉得更通俗易懂，就是不停的矮子里拔将军，哈哈。 0-1背包问题&#8195;&#8195;背包问题是比较经典的问题，由此演绎的版本也有很多，像什么海盗船装载问题，冒泡排序的理念和贪心算法也相似。这里就说一个最原始0-1背包问题。 &#8195;&#8195;.问题描述:. 假设有几个物品，其体积和价值如下表所示：| | 物品一 | 物品二 | 物品三 | 物品四 | 物品五 || ———— | ——-: | :——: |:——: |:——: |:——: || 体积 | 6 | 7 | 4 | 3 | 10 || 价值 | 18 | 14 | 16 | 15 | 25 | &#8195;&#8195;现在你有一个背包，可以容纳的最大体积是10，那么怎么装物品，会得到比较多的价值（所有物品不可分割）？ &#8195;&#8195;这是一道比较经典的0-1背包问题，背包问题的求解方法有很多，贪心、回溯、动态规划等等都可以解答，后续随着学习的深入，慢慢介绍，今天先说用贪心法求解。题目最后要求的结果是，获取比较多的价值，我们很容易想到按物品价值从高到低排序，依次取就行了呗，这算是一种价值贪心算法；题目中又说背包可容纳的最大体积是10，我们也很容易想到根据物品的体积从小到大排序，依次取，当然这也是一种贪心算法，体积优先；当然还可以用这两种算法折中的办法，单位体积优先，就是价值/体积的排序贪心算法，主要核心代码如下（本文代码地址https://github.com/wangpengda/algorithm/tree/master/Greedy） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package Model;import java.util.*;public class Goods implements Comparable&lt;Goods&gt; &#123; public Goods() &#123; &#125; public Goods(double size, double value) &#123; this.Id = java.util.UUID.randomUUID().toString(); this.Name = "都行"; this.Size = size; this.Value = value; this.PerValue = value / size; &#125; private String Id;//唯一标识 private String Name;//没有实际意义 private double Size;//体积 private double Value;//价值 private double PerValue;//平均价值 public String getId() &#123; return Id; &#125; public void setId(String id) &#123; Id = id; &#125; public String getName() &#123; return Name; &#125; public void setName(String name) &#123; Name = name; &#125; public double getSize() &#123; return Size; &#125; public void setSize(double size) &#123; Size = size; &#125; public double getValue() &#123; return Value; &#125; public void setValue(double value) &#123; Value = value; &#125; public double getPerValue() &#123; return PerValue; &#125; public void setPerValue(double perValue) &#123; PerValue = perValue; &#125; @Override public int compareTo(Goods g) &#123; //按size排序// if (g.Size &gt;= this.Size) return -1;// else return 1; //按平均价值排序 if (g.PerValue &gt;= this.PerValue) return 1; else return -1; &#125;&#125; &#8195;&#8195;我们用贪心算法求解的这个问题，最后得到的结果是物品三、四，最终的价值是31，但是其实由于这道题的物品数量很少，直接用眼看也能看出来，最优解应该是物品一、三，最优价值是34。所以物品不可分割的0-1背包问题，用贪心算法有时候只能得到近似解，不一定能得到最优解。当然，现实生活中，有些问题并不要求一定得到最优解，那么选择贪心算法得到近似解的方法就可以考虑选用。 Dijkstra算法&#8195;&#8195;记得上学的时候，学过一个经典的问题是最短路径问题，工作中也没怎么碰到过，当然如果有从事地图算法相关工作的同学，相信对于这个问题肯定不陌生。其实现实生活中，我们肯定遇到过类似的问题，比如国庆假期出去旅游，准备从北京出发，去济南、郑州、西安、拉萨、九寨这几个地方玩，要选择怎么样的路线比较好呢？我只是举个最短路径算法的例子，现实中，各位不差钱的大佬可能直接就来场说走就走的旅行就ok了，哈哈。 &#8195;&#8195;言归正传，这类问题用算法图的语言表述就是，给定有向带权图G=（V,E），每条边的权重非负数，给定V中的一个定点为源点，从源点出发，计算到所有其他点的最短路径长度。 &#8195;&#8195;解决这类问题，有个非常著名的算法，叫做Dijkstra（迪杰斯特拉）算法，记得数据结构一书中应该学过，不过当时应该算一脸懵逼，现在再回忆一下。Dijkstra算法是解决单元最短路径的贪心算法，先求出最短路径，再参照该路径求次短路径，直到求出源点到各点的所有最短路径。具体细节我在这就不详细赘述了，有兴趣的可以回去翻翻数据结构的书，或者网上查查具体逻辑，用java代码实现了一下，感兴趣可以组织组织数据结构，调一下算法试一下，核心代码如下所示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import Model.*;import java.util.*;//迪杰斯特拉算法public class Dijkstra &#123; public static final int MAX_DISTANCE = 9999999; public static DijResult Calculation(DijGraph g, String p) &#123; List&lt;String&gt; graphpoints = g.getPoints(); if (!graphpoints.contains(p)) return null;//判断是否是图中的点，不是即返回null int[][] matrixG = g.getMatrixG(); boolean[] checkflag = new boolean[graphpoints.size()]; String[] prev = new String[graphpoints.size()]; int[] dist = new int[graphpoints.size()]; int indexofp = graphpoints.indexOf(p); for (int i = 0; i &lt; checkflag.length; i++) &#123; checkflag[i] = false;//初始化检查数组 dist[i] = Math.min(MAX_DISTANCE, matrixG[indexofp][i]);//初始化距离数组 &#125; checkflag[indexofp] = true;//初始化原点P对应的检查数据 dist[indexofp] = 0;//初始化原点P对应的距离数组 int nearindex = indexofp; for (int i = 0; i &lt; graphpoints.size(); i++) &#123; int min = MAX_DISTANCE; //在没有找过的剩下的点中，循环取距离当前点最近的点 for (int j = 0; j &lt; graphpoints.size(); j++) &#123; if (checkflag[j] == false &amp;&amp; dist[j] &lt; min) &#123; min = dist[j]; nearindex = j; &#125; &#125; for (int j = 0; j &lt; graphpoints.size(); j++) &#123; //对比上一个节点 和 最短距离数组，更新数组 int tmpdist = Math.min(MAX_DISTANCE, min + matrixG[nearindex][j]); if (checkflag[j] == false &amp;&amp; tmpdist &lt; dist[j]) &#123; dist[j] = tmpdist; prev[j] = graphpoints.get(nearindex); &#125; &#125; &#125; return new DijResult(prev,dist); &#125;&#125; 结语&#8195;&#8195;很多问题的方案都可以用到贪心算法，像书中提到的哈夫曼编码、最小生成树等，还有像磁盘存储、生产调度等等，都可以设计。贪心算法的优势是速度快，很明显，大家也能看出来，用当下的流行语描述下它的思想就是，“干就完了”，它不考虑大局，局部咔咔就是干；缺点也很明显，就是有时候算出来的并不是最优解，只能得到个近似解。 &#8195;&#8195;最近因为工作的原因，个人自身学习上抽不出太多时间，后续尽量争取能挤出时间，继续该系列的学习。 备注：期间个人博客增加了背景音乐、在线联系、Fork me等功能，欢迎来踩。另外，java的开发工具，从eclipse换成了idea，貌似确实体验比eclipse好一点，哈哈。生命不息，折腾不止。]]></content>
      <categories>
        <category>自我升华</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[趣学算法(1)--从Fibonacci说起]]></title>
    <url>%2F2018%2F12%2F20%2F%E8%B6%A3%E5%AD%A6%E7%AE%97%E6%B3%95-1-%E4%BB%8EFibonacci%E8%AF%B4%E8%B5%B7%2F</url>
    <content type="text"><![CDATA[&#8195;&#8195;由于最近工作中，也可以说是个人爱好吧，涉及到一些算法的问题，个人归结起来觉得应该是NP-Hard问题，一时找不到好的解决方案。于是网上各种搜索，偶然翻到一本《趣学算法》的书，大致看了两眼，发现曾经学过的一些算法 像回溯、贪心等算法，由于长时间不用，也都忘记了。于是决定在工作之余，同时借助这本书的机会，再系统学习下算法，争取在学习过程中，能找到我那NP-Hard问题的解决方案。 &#8195;&#8195;抛砖引玉，先从一个程序员都非常熟悉的斐波那契数列算法说起，感受一下算法的趣味。说起斐波那契，程序员们应该都非常熟悉了，估计是曾经我们学习递归时候的重点案例吧，但是除了递归还有没有别的方法呢？或者说我们有没有考虑过，结果是算对了，但是背后的效率怎么样呢？ 方法一&#8195;&#8195;先从熟悉的递归方法说起： &#8195;&#8195;斐波那契数列应该都知道，据说大自然很多现象也都是斐波那契数，有兴趣的可以去查查，这里就不多介绍了，概念说一下，用函数公式的方式表示，大概是这个意思： F_n=\begin{cases} 1, & n = 1\ or\ n = 2\\ F_{n-1}+F_{n-2}, & n>2 \end{cases}递归算法代码最容易理解，就是反复迭代调用自己往下计算，代码基本和上述表达式一样，如下（本文章代码均用java编写，样例代码地址https://github.com/wangpengda/algorithm): 12345678910111213141516171819import java.text.SimpleDateFormat;import java.util.Date;public class Fib &#123; public static void main(String[] args) throws InterruptedException &#123; SimpleDateFormat sdf = new SimpleDateFormat("YYYY/MM/dd HH:mm:ss.SSS"); System.out.println(sdf.format(new Date())); System.out.println(Fib1(40)); System.out.println(sdf.format(new Date())); &#125; public static int Fib1(int n) &#123; if (n == 1 || n == 2) return 1; else return Fib1(n - 1) + Fib1(n - 2); &#125;&#125; &#8195;&#8195;这个很容易理解，但是不知道有没有人用这个算过F(50),我这8G内存，4核电脑是算了半天没算出来。再专业一点就是看一下它的时间复杂度，仔细分析会发现是指数增长的，往后算，每多算一个数，时间是翻倍的，它的时间复杂度是O(2^n); 方法二&#8195;&#8195;其实斐波那契归根结底还是个数列问题，就和我们高中学的等差数列、等比数列差不多，只是它是和用当前项的前两项表示的，我们只需要记录下前两项就可以了，而不用像递归算法那样，每次都去计算前两项，具体代码如下 123456789101112131415161718192021222324252627282930import java.text.SimpleDateFormat;import java.util.Date;public class Fib &#123; public static void main(String[] args) throws InterruptedException &#123; SimpleDateFormat sdf = new SimpleDateFormat("YYYY/MM/dd HH:mm:ss.SSS"); System.out.println(sdf.format(new Date())); System.out.println(Fib2(48)); System.out.println(sdf.format(new Date())); &#125; public static int Fib2(int n) &#123; if (n == 1 || n == 2) return 1; else &#123; int numsecond = 1; int numfirst = 1; int temp = 1; for (int i = 3; i &lt;= n; i++) &#123; temp = numsecond + numfirst; numfirst = numsecond; numsecond = temp; &#125; return numsecond; &#125; &#125;&#125; &#8195;&#8195;这个算法的时间复杂度是O(n),用这个算F(10000)基本也在1秒之内，就是这么神奇啊。按理说这个写法速度上已经是质的飞跃了，但是… 方法三&#8195;&#8195;书上简单提了一句，还可以把时间复杂度降到O(logn),不过没有详细赘述。好事者如我，本着不打破砂锅的程序员不是好厨师的原则，继续搜索。不得不说，确实有大师，用矩阵的方法，也是让我开了眼界啊，具体看下列表达式： \left(\begin{array}{c} F_n \\ F_{n-1} \end{array}\right)=\left(\begin{array}{c} F_{n-1}+F_{n-2} \\ F_{n-1} \end{array}\right)=\left(\begin{array}{c} 1*F_{n-1}+1*F_{n-2} \\ 1*F_{n-1}+0*F_{n-2} \end{array}\right)=\left(\begin{array}{cc} 1 & 1 \\ 1 & 0 \end{array}\right)*\left(\begin{array}{c} F_{n-1} \\ F_{n-2} \end{array}\right)\\ =\left(\begin{array}{cc} 1 & 1 \\ 1 & 0 \end{array}\right)^2*\left(\begin{array}{c} F_{n-2} \\ F_{n-3} \end{array}\right)......=\left(\begin{array}{cc} 1 & 1 \\ 1 & 0 \end{array}\right)^{n-2}*\left(\begin{array}{c} F_2 \\ F_1 \end{array}\right)&#8195;&#8195;看着上述表达式，有什么感想？耳边曾经经常响起的大学课程无用论是否还在回荡？事实证明，学校的课程还是相当有用的啊，不懂矩阵的回去查查大学线性代数，😄 。回过头来再说斐波那契问题，上述表达式把数列问题就转换成了，计算一个2*2矩阵的n-2次幂的问题,幂运算就可以用二分法运算降低时间复杂度了，简单说一下大概思路，就比如算2的32次幂，最简单办法肯定是循环31次，用2挨个乘；二分法的意思就是2的32次幂 可以转换为 2的16次幂乘以2的16次幂，2的16次幂 还可以转换为 2的8次幂乘以2的8次幂，……，以此类推，大概循环5次即可算出最后结果。思路大概就是这么个思路，网上代码是用python实现的，python里有成熟的计算矩阵的函数，我自己用java实现了一下，具体代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import java.text.SimpleDateFormat;import java.util.Date;public class Fib &#123; public static void main(String[] args) throws InterruptedException &#123; SimpleDateFormat sdf = new SimpleDateFormat("YYYY/MM/dd HH:mm:ss.SSS"); System.out.println(sdf.format(new Date())); System.out.println(Fib3(48)); System.out.println(sdf.format(new Date())); &#125; public static int Fib3(int n) &#123; if (n == 1 || n == 2) return 1; else &#123; int[][] a = new int[2][2];//用二维数组模拟2*2矩阵 a[0][0] = 1; a[0][1] = 1; a[1][0] = 1; a[1][1] = 0; int[][] temp = matricPow(a, n - 2); return temp[0][0] + temp[0][1]; &#125; &#125; //矩阵相乘计算 目前只支持2*2矩阵相乘 public static int[][] matricMulity(int[][] a, int[][] b) &#123; int[][] result = new int[2][2]; result[0][0] = a[0][0] * b[0][0] + a[0][1] * b[1][0]; result[0][1] = a[0][0] * b[0][1] + a[0][1] * b[1][1]; result[1][0] = a[1][0] * b[0][0] + a[1][1] * b[1][0]; result[1][1] = a[1][0] * b[0][1] + a[1][1] * b[1][1]; return result; &#125; //2*2矩阵幂运算 public static int[][] matricPow(int[][] a, int n) &#123; if (n == 0) return new int[][] &#123; &#123; 1, 1 &#125;, &#123; 1, 0 &#125; &#125;; if (n == 1) &#123; return a; &#125; if (n % 2 == 0) return matricPow(matricMulity(a, a), n / 2); else &#123; return matricMulity(matricPow(matricMulity(a, a), (n - 1) / 2), a); &#125; &#125;&#125; &#8195;&#8195;n比较小的时候，方法二和方法三计算时间差不多，n特别大才能看出些效果，当n=1,000,000时，方法一就不考虑了，今年应该算不出来。方法二和方法三，计算时间如下： 12345672018/12/20 22:38:11.81118847551312018/12/20 22:38:11.8212018/12/20 22:38:13.82218847551312018/12/20 22:38:13.823 &#8195;&#8195;两种方法计算第100万位基本还在毫秒级别，一般情况可能第二种方法就够用了，但是你不研究第三种方法，是体会不到第三种方法的乐趣的，呵呵~~~ 备注：本文章中所有公式都是用markdown代码编写，不是图片，不是word。第一次用markdown，基本也是第一次用java写程序，生命在于折腾嘛。后续我再研究研究将github的博客打开评论，希望各位来拍砖。]]></content>
      <categories>
        <category>自我升华</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新的起点]]></title>
    <url>%2F2018%2F12%2F19%2F%E6%96%B0%E7%9A%84%E8%B5%B7%E7%82%B9%2F</url>
    <content type="text"><![CDATA[&#8195;&#8195;新公司入职正好一个月，记录一下。 &#8195;&#8195;从今天开始定期写博客，方方面面的，刚开始用markdown和github写博客，不太习惯，慢慢习惯。]]></content>
      <categories>
        <category>人生感悟</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
