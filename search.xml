<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>算算基金收益</title>
    <url>/2020/08/03/%E7%AE%97%E7%AE%97%E5%9F%BA%E9%87%91%E6%94%B6%E7%9B%8A/</url>
    <content><![CDATA[<p>&#8195;&#8195;这两个月A股股市大火啊，随着世界范围的疫情爆发，除了中国外的其他国家经济都受到了沉重打击，也不得不说我国这波疫情控制已经不能用牛X来形容了。大A股也是在7月份差点走出一个疯牛的态势，同时也再次上了新闻，新闻里广大股民也是赚的不亦乐乎，不过我还是要官方的提醒一下大家，投资有风险，入市需谨慎。<br>&#8195;&#8195;我媳妇也加入了投资大军中，不过之前吃过股市的苦，再加上过年的时候阴差阳错让银行强力推荐了一个基金，放到现在涨势还可以，所以这一波，她多买了点。那多买了多少呢？ 银行 支付宝 加天天基金，到处买，总共买了10多支，这一天天忙的不亦乐乎，算收益都算一会儿，各个平台更新数据时间还不一致。我说我给你写个统计程序吧，省得你天天忙的跟特朗普似的。<br>&#8195;&#8195;于是开始找各种基金的接口，很多都是收费的，终于找了个可以免费用的，<a href="https://www.doctorxiong.club/api/" target="_blank" rel="noopener">https://www.doctorxiong.club/api/</a>  ，当然它也有收费的内容，但是免费的对于我算个收益来说也够用了。里边具体接口的内容就补赘述了，感兴趣的可以去看看文档，股票基金的都有。有了接口算收益就容易了，公式 现有份额*净值-成本金额 就是当前基金的累积收益，测试了几天那是相当准，跟软件上的结果完全一致。<br>&#8195;&#8195;首先先让我媳妇整理一下持有基金的基础数据，整理到excel里，主要是基金代码 持有份额 成本金额，如下图<br><img src="/2020/08/03/算算基金收益/myfunds.jpg" alt><br>&#8195;&#8195;基准价 手续费之前想用，目前没用，就先放着了。<br>&#8195;&#8195;接下来就是读这个excel基金数据，挨个算收益，然后再按照日期输出个excel结果，代码如下：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> xlwt</span><br><span class="line"><span class="keyword">import</span> xlrd</span><br><span class="line"><span class="keyword">from</span> StaticResult <span class="keyword">import</span> Result</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> date, timedelta</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">prev_weekday</span><span class="params">(adate)</span>:</span></span><br><span class="line">    adate -= timedelta(days=<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">while</span> adate.weekday() &gt; <span class="number">3</span>: <span class="comment"># Mon-Fri are 0-4</span></span><br><span class="line">        adate -= timedelta(days=<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> adate</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getFundDetail</span><span class="params">(fundcode)</span>:</span></span><br><span class="line">    s = requests.session()</span><br><span class="line">    s.keep_alive = <span class="keyword">False</span></span><br><span class="line">    s.proxies = &#123;<span class="string">"http"</span>: <span class="string">"36.249.49.17:9999"</span>, <span class="string">"http"</span>: <span class="string">"123.169.38.64:9999"</span>, &#125;</span><br><span class="line">    <span class="comment">#s.headers = &#123;'Connection':'close'&#125;</span></span><br><span class="line">    url = <span class="string">"https://api.doctorxiong.club/v1/fund/detail?code="</span> + fundcode</span><br><span class="line">    r = s.get(url)</span><br><span class="line">    print(r.status_code)</span><br><span class="line">    content = r.text</span><br><span class="line">    <span class="keyword">return</span> json.loads(content)[<span class="string">"data"</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    res = []</span><br><span class="line">    todaydate = datetime.datetime.now()</span><br><span class="line">    hours = datetime.timedelta(hours=<span class="number">21</span>)</span><br><span class="line">    todaydate = todaydate - hours</span><br><span class="line">    <span class="comment">#yesterdaydate =todaydate + datetime.timedelta(-1)</span></span><br><span class="line">    yesterdaydate = prev_weekday(todaydate)</span><br><span class="line">    today = todaydate.strftime(<span class="string">"%Y-%m-%d"</span>)</span><br><span class="line">    yesterday = yesterdaydate.strftime(<span class="string">"%Y-%m-%d"</span>)</span><br><span class="line">    yesterdaybook = xlrd.open_workbook(<span class="string">"./statistics/"</span>+yesterday+<span class="string">".xls"</span>)</span><br><span class="line">    yesterdaytable = yesterdaybook.sheet_by_name(<span class="string">'Sheet1'</span>)</span><br><span class="line">    yesterdayrows = yesterdaytable.nrows</span><br><span class="line">    book = xlrd.open_workbook(<span class="string">"./myfunds.xlsx"</span>)</span><br><span class="line">    table = book.sheet_by_name(<span class="string">'Sheet1'</span>)</span><br><span class="line">    rows = table.nrows</span><br><span class="line">    <span class="keyword">if</span> rows &gt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> range(<span class="number">1</span>,rows):</span><br><span class="line">            fundcode = table.row(num)[<span class="number">0</span>].value</span><br><span class="line">            baseprice = table.row(num)[<span class="number">2</span>].value</span><br><span class="line">            baseMoney = table.row(num)[<span class="number">3</span>].value</span><br><span class="line">            basecount = table.row(num)[<span class="number">4</span>].value</span><br><span class="line">            <span class="keyword">if</span> basecount == <span class="string">''</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            cost = baseMoney</span><br><span class="line">            feein = table.row(num)[<span class="number">5</span>].value</span><br><span class="line">            feeout = table.row(num)[<span class="number">6</span>].value</span><br><span class="line">            fund = getFundDetail(fundcode)</span><br><span class="line">            fundnewprice = float(fund[<span class="string">"netWorth"</span>])</span><br><span class="line">            fundname = fund[<span class="string">"name"</span>]</span><br><span class="line">            print(fundcode)</span><br><span class="line">            totalprofit1 = (fundnewprice)*basecount - cost</span><br><span class="line">            todayprofit = totalprofit1 - yesterdaytable.row(num<span class="number">-1</span>)[<span class="number">2</span>].value</span><br><span class="line">            fundres = Result(fundcode,fundname,<span class="number">0</span>,totalprofit1,todayprofit)</span><br><span class="line">            res.append(fundres)</span><br><span class="line"></span><br><span class="line">            print(<span class="string">"ok"</span>)</span><br><span class="line">        </span><br><span class="line">        filename = <span class="string">"./statistics/"</span>+today+<span class="string">".xls"</span></span><br><span class="line">        workbook = xlwt.Workbook(encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">        sheet = workbook.add_sheet(<span class="string">'Sheet1'</span>)</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> d <span class="keyword">in</span> res:</span><br><span class="line">            sheet.write(i,<span class="number">0</span>,d.fundcode)</span><br><span class="line">            sheet.write(i,<span class="number">1</span>,d.fundname)</span><br><span class="line">            sheet.write(i,<span class="number">2</span>,d.totalprofit)</span><br><span class="line">            sheet.write(i,<span class="number">3</span>,d.todayprofit)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        workbook.save(filename)</span><br><span class="line">    print(<span class="string">"ok"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="string">'__main__'</span> == __name__:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></p>
<p>&#8195;&#8195;之前读取基金接口用的本地地址，运行几天之后，就提醒连接出错了，网上查了查说用代理方式能解决，就改了下代理方式，确实完美解决，python确实火啊，各种类库，各种社区，确实蓬勃发展。这是小插曲，上边程序计算了每个基金的收益，按天统计，运行几天就能归档一系列的文档，如下图<br><img src="/2020/08/03/算算基金收益/list.jpg" alt> <img src="/2020/08/03/算算基金收益/profit.jpg" alt><br>&#8195;&#8195;<br>&#8195;&#8195;这样就有了每天的收益明细，然后每天开一下excel，全选下收益那列，就能知道总的收益了。但是作为程序员，怎么能容忍每天还得打开一下，全选一下，这绝对忍不了。于是，针对以上excel列表，我又写了个程序，自动统计，自动形成趋势图，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> xlwt</span><br><span class="line"><span class="keyword">import</span> xlrd</span><br><span class="line"><span class="keyword">import</span> xlsxwriter</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    dict = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(<span class="string">"./statistics"</span>):</span><br><span class="line">        <span class="keyword">for</span> f <span class="keyword">in</span> files:</span><br><span class="line">            fdate = f[<span class="number">0</span>:<span class="number">-4</span>]</span><br><span class="line">            fpath = os.path.join(root, f)</span><br><span class="line">            book = xlrd.open_workbook(fpath)</span><br><span class="line">            table = book.sheet_by_name(<span class="string">'Sheet1'</span>)</span><br><span class="line">            rows = table.nrows</span><br><span class="line">            total = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> range(<span class="number">0</span>,rows):</span><br><span class="line">                total+= table.row(num)[<span class="number">2</span>].value</span><br><span class="line">            dict[fdate] = total</span><br><span class="line">    workbook = xlsxwriter.Workbook(<span class="string">"./trend.xlsx"</span>)</span><br><span class="line">    sheet = workbook.add_worksheet(<span class="string">'trend'</span>)</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> d <span class="keyword">in</span> dict:</span><br><span class="line">        sheet.write(i,<span class="number">0</span>,d)</span><br><span class="line">        sheet.write(i,<span class="number">1</span>,dict[d])</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    chart_col = workbook.add_chart(&#123;<span class="string">'type'</span>: <span class="string">'line'</span>&#125;)</span><br><span class="line">    chart_col.add_series(&#123;</span><br><span class="line">    <span class="comment"># 这里的sheet1是默认的值，因为我们在新建sheet时没有指定sheet名</span></span><br><span class="line">    <span class="comment"># 如果我们新建sheet时设置了sheet名，这里就要设置成相应的值</span></span><br><span class="line">        <span class="string">'name'</span>: <span class="string">'收益趋势图'</span>,</span><br><span class="line">        <span class="string">'categories'</span>: <span class="string">'=trend!$A$1:$A$'</span>+str(i),</span><br><span class="line">        <span class="string">'values'</span>:   <span class="string">'=trend!$B$1:$B$'</span>+str(i),</span><br><span class="line">        <span class="string">'line'</span>: &#123;<span class="string">'color'</span>: <span class="string">'red'</span>&#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">    chart_col.set_title(&#123;<span class="string">'name'</span>: <span class="string">'收益趋势图'</span>&#125;)</span><br><span class="line">    <span class="comment">#chart_col.set_x_axis(&#123;'name': '日期'&#125;)</span></span><br><span class="line">    <span class="comment">#chart_col.set_y_axis(&#123;'name':  '收益'&#125;)</span></span><br><span class="line">    </span><br><span class="line">    chart_col.set_style(<span class="number">1</span>)</span><br><span class="line"> </span><br><span class="line">    sheet.insert_chart(<span class="string">'H3'</span>, chart_col, &#123;<span class="string">'x_offset'</span>: <span class="number">25</span>, <span class="string">'y_offset'</span>: <span class="number">10</span>&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#workbook.save("./trend.xls")</span></span><br><span class="line">    </span><br><span class="line">    workbook.close()</span><br><span class="line">    print(dict)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="string">'__main__'</span> == __name__:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>&#8195;&#8195;执行后结果如下图：<br><img src="/2020/08/03/算算基金收益/trend.jpg" alt><br>&#8195;&#8195;这下就基本完美了，每天运行俩下程序就行了，自动形成收益趋势图。<br>&#8195;&#8195;后来想想，既然能读取到基金的基础信息，包含净值 估值 持仓，那我不是能统计出现在大基金们重仓的股票有哪些了？大基金持仓的股票会随便跌吗？于是兴趣来了，又写了个统计基金重仓股的程序，代码如下：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> xlwt</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="comment">#HEADERS = &#123;'Content-Type': 'application/x-www-form-urlencoded;charset=utf-8', 'Key': '332213fa4a9d4288b5668ddd9'&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getGupiao</span><span class="params">(fundcode)</span>:</span></span><br><span class="line">    url = <span class="string">"https://api.doctorxiong.club/v1/fund/position?code="</span> + fundcode</span><br><span class="line">    content = requests.get(url).text</span><br><span class="line">    <span class="keyword">return</span> json.loads(content)[<span class="string">"data"</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getFundDetail</span><span class="params">(fundcode)</span>:</span></span><br><span class="line">    url = <span class="string">"https://api.doctorxiong.club/v1/fund/detail?code="</span> + fundcode</span><br><span class="line">    content = requests.get(url).text</span><br><span class="line">    <span class="keyword">return</span> json.loads(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    todaydate = datetime.datetime.now()</span><br><span class="line">    today = todaydate.strftime(<span class="string">"%Y-%m-%d"</span>)</span><br><span class="line">    dict = &#123;&#125;</span><br><span class="line">    dict2 = &#123;&#125;</span><br><span class="line">    dict3 = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> range(<span class="number">15</span>,<span class="number">30</span>):</span><br><span class="line">        data = &#123;<span class="string">"sort"</span>:<span class="string">"lastMonthGrowth"</span>,<span class="string">"creatTimeLimit"</span>:<span class="string">"2"</span>,<span class="string">"fundScale"</span>:<span class="string">"101"</span>,<span class="string">"pageIndex"</span>:num,<span class="string">"pageSize"</span>:<span class="string">"10"</span>&#125;</span><br><span class="line">        content  = requests.post(url=<span class="string">"https://api.doctorxiong.club/v1/fund/rank"</span>,json=data).text</span><br><span class="line">        jsoncontent = json.loads(content)</span><br><span class="line">        fundlist = jsoncontent[<span class="string">"data"</span>][<span class="string">"rank"</span>]</span><br><span class="line">        print(num)</span><br><span class="line">        <span class="keyword">for</span> fund <span class="keyword">in</span> fundlist:</span><br><span class="line">            <span class="comment">#funddetail = getFundDetail(fund["code"])</span></span><br><span class="line">            <span class="comment">#fundprice = float(funddetail["data"]["fundScale"][0:-1])</span></span><br><span class="line">            fundstock = getGupiao(fund[<span class="string">"code"</span>])</span><br><span class="line">            print(fund[<span class="string">"code"</span>])</span><br><span class="line">            <span class="keyword">if</span> fundstock <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> fundstock[<span class="string">"total"</span>] <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> fundstock[<span class="string">"stock"</span>] <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            fundprice = float(fundstock[<span class="string">"total"</span>])</span><br><span class="line">            stockpercent = float(fundstock[<span class="string">"stock"</span>][<span class="number">0</span>:<span class="number">-1</span>])/<span class="number">100</span></span><br><span class="line">            fundgpprice = fundprice * stockpercent</span><br><span class="line">            stocklist = fundstock[<span class="string">"stockList"</span>]</span><br><span class="line">            <span class="keyword">for</span> gp <span class="keyword">in</span> stocklist:</span><br><span class="line">                gpcode = gp[<span class="number">0</span>]</span><br><span class="line">                gppercent = float(gp[<span class="number">2</span>][<span class="number">0</span>:<span class="number">-1</span>])/<span class="number">100</span></span><br><span class="line">                gpprice = fundgpprice * gppercent</span><br><span class="line">                <span class="keyword">if</span> gpcode <span class="keyword">in</span> dict:</span><br><span class="line">                    thisgptotal = dict[gpcode] + gpprice</span><br><span class="line">                    dict[gpcode] = thisgptotal</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dict[gpcode] = gpprice</span><br><span class="line">                <span class="keyword">if</span> gpcode <span class="keyword">in</span> dict2:</span><br><span class="line">                    thisgptotal = dict2[gpcode] + <span class="number">1</span></span><br><span class="line">                    dict2[gpcode] = thisgptotal</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dict2[gpcode] = <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> gpcode <span class="keyword">in</span> dict3:</span><br><span class="line">                    thisgptotal = dict3[gpcode]+<span class="string">"/"</span>+fund[<span class="string">"code"</span>]</span><br><span class="line">                    dict3[gpcode] = thisgptotal</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dict3[gpcode] = fund[<span class="string">"code"</span>]</span><br><span class="line">    dict = sorted(dict.items(), key=<span class="keyword">lambda</span> d:d[<span class="number">1</span>], reverse = <span class="keyword">True</span>)</span><br><span class="line">    dict2 = sorted(dict2.items(), key=<span class="keyword">lambda</span> d:d[<span class="number">1</span>], reverse = <span class="keyword">True</span>)</span><br><span class="line">    dict3 = sorted(dict3.items(), key=<span class="keyword">lambda</span> d:d[<span class="number">1</span>], reverse = <span class="keyword">True</span>)</span><br><span class="line">    workbook = xlwt.Workbook(encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">    sheet = workbook.add_sheet(<span class="string">'fundgp'</span>)</span><br><span class="line">    sheet2 = workbook.add_sheet(<span class="string">'fundgp2'</span>)</span><br><span class="line">    sheet3 = workbook.add_sheet(<span class="string">'fundgp3'</span>)</span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> d <span class="keyword">in</span> dict:</span><br><span class="line">        sheet.write(i,<span class="number">1</span>,d[<span class="number">0</span>])</span><br><span class="line">        sheet.write(i,<span class="number">2</span>,d[<span class="number">1</span>])</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    j = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> d <span class="keyword">in</span> dict2:</span><br><span class="line">        sheet2.write(j,<span class="number">1</span>,d[<span class="number">0</span>])</span><br><span class="line">        sheet2.write(j,<span class="number">2</span>,d[<span class="number">1</span>])</span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">    k = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> d <span class="keyword">in</span> dict3:</span><br><span class="line">        sheet3.write(k,<span class="number">1</span>,d[<span class="number">0</span>])</span><br><span class="line">        sheet3.write(k,<span class="number">2</span>,d[<span class="number">1</span>])</span><br><span class="line">        k += <span class="number">1</span></span><br><span class="line">    workbook.save(<span class="string">"./fundtrend/"</span>+today+<span class="string">".xls"</span>)</span><br><span class="line">    print(dict)</span><br><span class="line">    print(dict3)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="string">'__main__'</span> == __name__:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></p>
<p>&#8195;&#8195;这个统计主要统计了大基金重仓股的总持有金额，热点股票有多少家大基金持有，数据出来之后，发现重仓的基本是茅台 五粮液 腾讯直流，哎，我等小散也是买不起啊。不过这一篇以及上一篇博客主要是熟悉学习python，发现上手基本没啥难度，接下来可能为研究研究机器学习打打基础。这篇就到这吧，如有人有兴趣，可一起留言交流。</p>
]]></content>
      <categories>
        <category>闲情逸致</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>螺旋矩阵</title>
    <url>/2020/07/30/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<p>&#8195;&#8195;今天偶然在一个技术群里看到，一个刚毕业的小伙子面试，说有道面试题是什么打印螺旋矩阵没写出来。这应该是道比较成熟的面试题，但是我之前没遇到过，挑起了兴趣，最近也在研究python，写写程序实操一下。<br>&#8195;&#8195;螺旋矩阵大概意思就是一个二维矩阵，转着圈打印出来，例如下边这个矩阵</p>
<script type="math/tex; mode=display">\begin{bmatrix}
1 & 2 & 3 & 4 \\
5 & 6 & 7 & 8\\
9 & 10 & 11 & 12 \\
13 & 14 & 15 & 16 \\
\end{bmatrix}</script><p>螺旋打印出来的结果应该是 1 2 3 4 8 12 16 15 14 13 9 5 6 7 11 10，就是从外层转到最里层。</p>
<p>&#8195;&#8195;这题用传统的循环，按情况计算，可能会循环的次数多点，但应该肯定是能解出来的。我的想法比较直接，循环打印就按它前进方向走呗，开始往右，然后往下，然后往左，然后往上，然后再往右循环复始，什么时候结束，矩阵里边的数数完就结束了呗。所以代码如下<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(row,col)</span>:</span></span><br><span class="line">    count = row * col</span><br><span class="line">    matrix = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(col)] <span class="keyword">for</span> i <span class="keyword">in</span> range(row)]</span><br><span class="line">    init = <span class="number">1</span></span><br><span class="line">    <span class="comment">#初始化矩阵</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,row):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>,col):</span><br><span class="line">            matrix[i][j] = init</span><br><span class="line">            init=init+<span class="number">1</span></span><br><span class="line">    <span class="comment">#打印初始矩阵</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>,row):</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">0</span>,col):</span><br><span class="line">            print(matrix[j][k],end=<span class="string">"\t"</span>)</span><br><span class="line">        print(<span class="string">"\n"</span>)</span><br><span class="line"></span><br><span class="line">    direc=[<span class="string">"→"</span>,<span class="string">"↓"</span>,<span class="string">"←"</span>,<span class="string">"↑"</span>] <span class="comment">#定义方向矩阵</span></span><br><span class="line">    direccount=[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>] <span class="comment">#定义各方向走的次数，确定每次走的边界</span></span><br><span class="line">    currentDirec = <span class="string">"→"</span> <span class="comment">#当前所走方向初始化</span></span><br><span class="line">    currentDirecIndex = <span class="number">0</span> <span class="comment">#当前所走方向索引初始化</span></span><br><span class="line">    crow = <span class="number">0</span> <span class="comment">#当前行索引</span></span><br><span class="line">    ccol = <span class="number">0</span> <span class="comment">#当前列索引</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,row*col):</span><br><span class="line">        <span class="keyword">if</span> currentDirec == <span class="string">"→"</span>:</span><br><span class="line">            <span class="keyword">if</span> ccol &lt; (col - direccount[(currentDirecIndex+<span class="number">1</span>)%<span class="number">4</span>]<span class="number">-1</span>):</span><br><span class="line">                print(matrix[crow][ccol],end=<span class="string">" "</span>)</span><br><span class="line">                ccol+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                direccount[currentDirecIndex]+=<span class="number">1</span></span><br><span class="line">                currentDirecIndex =  (currentDirecIndex+<span class="number">1</span>)%<span class="number">4</span></span><br><span class="line">                currentDirec = direc[currentDirecIndex]</span><br><span class="line">                print(matrix[crow][ccol],end=<span class="string">" "</span>)</span><br><span class="line">                crow+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> currentDirec == <span class="string">"↓"</span>:</span><br><span class="line">            <span class="keyword">if</span> crow &lt; (row - direccount[(currentDirecIndex+<span class="number">1</span>)%<span class="number">4</span>]<span class="number">-1</span>):</span><br><span class="line">                print(matrix[crow][ccol],end=<span class="string">" "</span>)</span><br><span class="line">                crow+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                direccount[currentDirecIndex]+=<span class="number">1</span></span><br><span class="line">                currentDirecIndex =  (currentDirecIndex+<span class="number">1</span>)%<span class="number">4</span></span><br><span class="line">                currentDirec = direc[currentDirecIndex]</span><br><span class="line">                print(matrix[crow][ccol],end=<span class="string">" "</span>)</span><br><span class="line">                ccol-=<span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> currentDirec == <span class="string">"←"</span>:</span><br><span class="line">            <span class="keyword">if</span> ccol &gt; (direccount[(currentDirecIndex+<span class="number">1</span>)%<span class="number">4</span>]):</span><br><span class="line">                print(matrix[crow][ccol],end=<span class="string">" "</span>)</span><br><span class="line">                ccol-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                direccount[currentDirecIndex]+=<span class="number">1</span></span><br><span class="line">                currentDirecIndex =  (currentDirecIndex+<span class="number">1</span>)%<span class="number">4</span></span><br><span class="line">                currentDirec = direc[currentDirecIndex]</span><br><span class="line">                print(matrix[crow][ccol],end=<span class="string">" "</span>)</span><br><span class="line">                crow-=<span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> currentDirec == <span class="string">"↑"</span>:</span><br><span class="line">            <span class="keyword">if</span> crow &gt; (direccount[(currentDirecIndex+<span class="number">1</span>)%<span class="number">4</span>]):</span><br><span class="line">                print(matrix[crow][ccol],end=<span class="string">" "</span>)</span><br><span class="line">                crow-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                direccount[currentDirecIndex]+=<span class="number">1</span></span><br><span class="line">                currentDirecIndex =  (currentDirecIndex+<span class="number">1</span>)%<span class="number">4</span></span><br><span class="line">                currentDirec = direc[currentDirecIndex]       </span><br><span class="line">                print(matrix[crow][ccol],end=<span class="string">" "</span>)</span><br><span class="line">                ccol+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="string">'__main__'</span> == __name__:</span><br><span class="line">    main(<span class="number">6</span>,<span class="number">5</span>)</span><br><span class="line">    print(<span class="string">"\n\n"</span>)</span><br></pre></td></tr></table></figure></p>
<p>结果如下<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">D:\work\code\python\Crawling&gt;set PYTHONIOENCODING=utf8 &amp;&amp; python -u &quot;d:\work\code\python\Crawling\.vscode\SpiralMatrix.py&quot;</span><br><span class="line">1       2       3       4       5</span><br><span class="line"></span><br><span class="line">6       7       8       9       10</span><br><span class="line"></span><br><span class="line">11      12      13      14      15</span><br><span class="line"></span><br><span class="line">16      17      18      19      20</span><br><span class="line"></span><br><span class="line">21      22      23      24      25</span><br><span class="line"></span><br><span class="line">26      27      28      29      30</span><br><span class="line"></span><br><span class="line">1 2 3 4 5 10 15 20 25 30 29 28 27 26 21 16 11 6 7 8 9 14 19 24 23 22 17 12 13 18</span><br></pre></td></tr></table></figure></p>
<p>&#8195;&#8195;主题代码逻辑其实还是比较简单的，多少个数就循环多少次，4个方向挨个走，遇到临近的交点的时候，处理一下方向标记和方向次数，确定下次走的边界，循环下去就可以了。<br>&#8195;&#8195;输出一个螺旋的矩阵逻辑基本也一样，稍微改改即可，代码如下：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">SpiralMatrix2</span><span class="params">(row,col)</span>:</span></span><br><span class="line">    matrix = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(col)] <span class="keyword">for</span> i <span class="keyword">in</span> range(row)]</span><br><span class="line"></span><br><span class="line">    direc=[<span class="string">"→"</span>,<span class="string">"↓"</span>,<span class="string">"←"</span>,<span class="string">"↑"</span>]</span><br><span class="line">    direccount=[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">    currentDirec = <span class="string">"→"</span></span><br><span class="line">    currentDirecIndex = <span class="number">0</span></span><br><span class="line">    crow = <span class="number">0</span></span><br><span class="line">    ccol = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,row*col):</span><br><span class="line">        <span class="keyword">if</span> currentDirec == <span class="string">"→"</span>:</span><br><span class="line">            <span class="keyword">if</span> ccol &lt; (col - direccount[(currentDirecIndex+<span class="number">1</span>)%<span class="number">4</span>]<span class="number">-1</span>):</span><br><span class="line">                (matrix[crow][ccol])=i+<span class="number">1</span></span><br><span class="line">                ccol+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                direccount[currentDirecIndex]+=<span class="number">1</span></span><br><span class="line">                currentDirecIndex =  (currentDirecIndex+<span class="number">1</span>)%<span class="number">4</span></span><br><span class="line">                currentDirec = direc[currentDirecIndex]</span><br><span class="line">                (matrix[crow][ccol])=i+<span class="number">1</span></span><br><span class="line">                crow+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> currentDirec == <span class="string">"↓"</span>:</span><br><span class="line">            <span class="keyword">if</span> crow &lt; (row - direccount[(currentDirecIndex+<span class="number">1</span>)%<span class="number">4</span>]<span class="number">-1</span>):</span><br><span class="line">                (matrix[crow][ccol])=i+<span class="number">1</span></span><br><span class="line">                crow+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                direccount[currentDirecIndex]+=<span class="number">1</span></span><br><span class="line">                currentDirecIndex =  (currentDirecIndex+<span class="number">1</span>)%<span class="number">4</span></span><br><span class="line">                currentDirec = direc[currentDirecIndex]</span><br><span class="line">                (matrix[crow][ccol])=i+<span class="number">1</span></span><br><span class="line">                ccol-=<span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> currentDirec == <span class="string">"←"</span>:</span><br><span class="line">            <span class="keyword">if</span> ccol &gt; (direccount[(currentDirecIndex+<span class="number">1</span>)%<span class="number">4</span>]):</span><br><span class="line">                (matrix[crow][ccol])=i+<span class="number">1</span></span><br><span class="line">                ccol-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                direccount[currentDirecIndex]+=<span class="number">1</span></span><br><span class="line">                currentDirecIndex =  (currentDirecIndex+<span class="number">1</span>)%<span class="number">4</span></span><br><span class="line">                currentDirec = direc[currentDirecIndex]</span><br><span class="line">                (matrix[crow][ccol])=i+<span class="number">1</span></span><br><span class="line">                crow-=<span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> currentDirec == <span class="string">"↑"</span>:</span><br><span class="line">            <span class="keyword">if</span> crow &gt; (direccount[(currentDirecIndex+<span class="number">1</span>)%<span class="number">4</span>]):</span><br><span class="line">                (matrix[crow][ccol])=i+<span class="number">1</span></span><br><span class="line">                crow-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                direccount[currentDirecIndex]+=<span class="number">1</span></span><br><span class="line">                currentDirecIndex =  (currentDirecIndex+<span class="number">1</span>)%<span class="number">4</span></span><br><span class="line">                currentDirec = direc[currentDirecIndex]       </span><br><span class="line">                (matrix[crow][ccol])=i+<span class="number">1</span></span><br><span class="line">                ccol+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>,row):</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">0</span>,col):</span><br><span class="line">            print(matrix[j][k],end=<span class="string">"\t"</span>)</span><br><span class="line">        print(<span class="string">"\n"</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="string">'__main__'</span> == __name__:</span><br><span class="line">    main(<span class="number">6</span>,<span class="number">5</span>)</span><br><span class="line">    print(<span class="string">"\n\n"</span>)</span><br><span class="line">    SpiralMatrix2(<span class="number">8</span>,<span class="number">8</span>)</span><br></pre></td></tr></table></figure></p>
<p>输出结果<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1       2       3       4       5       6       7       8</span><br><span class="line"></span><br><span class="line">28      29      30      31      32      33      34      9</span><br><span class="line"></span><br><span class="line">27      48      49      50      51      52      35      10</span><br><span class="line"></span><br><span class="line">26      47      60      61      62      53      36      11</span><br><span class="line"></span><br><span class="line">25      46      59      64      63      54      37      12</span><br><span class="line"></span><br><span class="line">24      45      58      57      56      55      38      13</span><br><span class="line"></span><br><span class="line">23      44      43      42      41      40      39      14</span><br><span class="line"></span><br><span class="line">22      21      20      19      18      17      16      15</span><br></pre></td></tr></table></figure></p>
<p>&#8195;&#8195;一些小算法还是挺有趣味的，代码什么的其实都无所谓，关键还是数据结构和思路。另外，虽然初学python，但是这东西真的很简单，但也很灵活还很强大。</p>
]]></content>
      <categories>
        <category>趣味算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>线性规划-2-单纯形解法2</title>
    <url>/2020/04/07/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92-2-%E5%8D%95%E7%BA%AF%E6%80%A7%E8%A7%A3%E6%B3%952/</url>
    <content><![CDATA[<p>&#8195;&#8195;这一篇紧接上一篇单纯形解法，如果看过上一篇的博客的，可能会诧异了，怎么上一篇感觉没写完就戛然而止了呢？额。。。很惭愧，本想随便举个例子，然后用基本单纯形法求解一下，熟悉一下求解过程，结果发现，随便举的例子有点特殊了，加了松弛变量（这种情况也称剩余变量）发现一下找不到基变量。哎，所以这几天又继续学习了下边的运筹学课程，这就要介绍一下基于基本单纯形法演化出来的M法和两阶段法。<br>&#8195;&#8195;首先我们化成标准型，添加如松弛变量，如下：</p>
<script type="math/tex; mode=display">s.t. \ \ \ \ 0.3*X_1 + 2*X_2 + 1*X_3 - X_4   = 70\\
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ 0.1*X_1 + 0.05*X_2 + 0.02*X_3 - X_5 =3\\
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ 0.05*X_1 + 0.1*X_2 + 0.02*X_3 - X_6 =3\\
X_1\geq0,X_2\geq0,X_3\geq0,X_4\geq0,X_5\geq0,X_6\geq0</script><p>&#8195;&#8195;但是这个变化是不容易找到基变量的，找不到怎么办？这里就要用到大M法，接着造变量，就这么暴力，不怕变量多。变化如下：</p>
<script type="math/tex; mode=display">s.t. \ \ \ \ 0.3*X_1 + 2*X_2 + 1*X_3 - X_4 +X_7  = 70\\
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ 0.1*X_1 + 0.05*X_2 + 0.02*X_3 - X_5 + X_8 =3\\
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ 0.05*X_1 + 0.1*X_2 + 0.02*X_3 - X_6 + X_9 =3\\
X_1\geq0,X_2\geq0,X_3\geq0,X_4\geq0,X_5\geq0,\\X_6\geq0,,X_7\geq0,X_8\geq0,X_9\geq0</script><p>&#8195;&#8195;X7 X8 X9被称作人工变量，很明显是我们人工造出来的。那么问题来了，原来方程组都是左右相等的，我们这么凭空加上三个变量还能相等？你的质疑是有道理的，所以我们如果这样假设它相等的话，那么目标函数也要相应变化，这就要引入之前说的M了，变化如下：</p>
<script type="math/tex; mode=display">Max \ \ \ \ -2*X_1 - 7*X_2 - 4*X_3 + M*X_7+ M*X_8+ M*X_9</script><p>&#8195;&#8195;是的，就是在每个人工变量前乘以M，M这里是任意大的正数，可以理解为正无穷大。好了，这样（X7，X8，X9）就可以作为初始基变量，接下来就可以列单纯行表来解决这个问题了，需要注意的是，最终的最优解一定是没有人工变量的，也就是最后的M一定是0，才能和最初的目的函数一致。如果找不到不含人工变量的最优解，那么该问题即没有最优解。🙂</p>
]]></content>
      <categories>
        <category>自我升华</category>
      </categories>
      <tags>
        <tag>运筹学</tag>
      </tags>
  </entry>
  <entry>
    <title>线性规划-2-单纯形解法</title>
    <url>/2020/03/27/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92-2-%E5%8D%95%E7%BA%AF%E6%80%A7%E8%A7%A3%E6%B3%95/</url>
    <content><![CDATA[<p>&#8195;&#8195;系列1初步认识了线性规划的数学模型，这就和我们小学初中的时候解应用题一样，假设未知数，列方程，求解；那么类似于配料问题，我们建立了线性规划的数学模型，那么怎么求解呢？怎么算得到最优解呢？<br>&#8195;&#8195;这一讲主要讲述线性规划入门经典解法，单纯性法。当然，线性规划再解之前，要先整理标准形式，还有一些专业术语，如可行解、基本解等等，这里不再详细阐述，不理解的可以先去随便找本线性规划的书，翻翻前几页就ok。本章主要针对上一章的例题，用单纯行法列出具体的求解过程：<br>&#8195;&#8195;用单纯行法求解线性规划，分为几步，具体如下：<br>&#8195;&#8195;&#8195;&#8195;<strong><em>1</em></strong>. 将线性规划问题化成标准型 <strong>(引入松弛变量或剩余变量)</strong><br>&#8195;&#8195;&#8195;&#8195;<strong><em>2</em></strong>. 找出或构造一个<strong>m阶单位矩阵</strong>（假设标准型限行规划问题是m<em>n阶矩阵）作为<strong>初始可行基</strong>，建立<strong>初始单纯形表</strong><br>&#8195;&#8195;&#8195;&#8195;**</em>3<strong>*. 计算各</strong>非基变量的检验数<strong>σj=cj−Εzj 若</strong>所有检验数≤0<strong>，则问题已得到</strong>最优解，停止计算<strong>。否则，转入下一步。(检验数)<br>&#8195;&#8195;&#8195;&#8195;*</strong>4<strong><em>. 在大于0的检验数中，若某个检验数对应的系数列向量≤ 0，则此问题是无界解，停止计算，否则转入下步。<br>&#8195;&#8195;&#8195;&#8195;</em></strong>5<strong>*. 根据max（检验数j | 检验数j&gt;0）=检验数k的原则，确定</strong>为换入变量(进基变量) 再按最小比值法则(biaik，&amp;aik&gt;0)确定换出变量<strong>，建立新的单纯形表，此时的基变量中xk代替的换出变量的位置。<br>&#8195;&#8195;&#8195;&#8195;*</strong>6<em>*</em>. 以aik为主元素进行迭代，把xk所对应的列向量变为单位列向量，即aik变为1 同列中其他元素变为0，继续计算各非基变量的检验数，进行第三步。</p>
<p>&#8195;&#8195;好，根据以上6步，解一下上一章的线性规划问题，首先先引入松弛变量，化成标准型，如下：</p>
<p>&#8195;&#8195;&#8195;&#8195;目标函数转换成求max</p>
<script type="math/tex; mode=display">Max \ \ \ \ -2*X_1 - 7*X_2 - 4*X_3</script><p>&#8195;&#8195;&#8195;&#8195;通过引入松弛变量，同时为了方便的找出初始可行解，转换成</p>
<script type="math/tex; mode=display">s.t. \ \ \ \ 0.3*X_1 + 2*X_2 + 1*X_3 - X_4 = 70\\
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ 0.1*X_1 + 0.05*X_2 + 0.02*X_3 - X_5 = 3\\
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ 0.05*X_1 + 0.1*X_2 + 0.02*X_3 - X_6 = 3\\
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ X_1\geq0,X_2\geq0,X_3\geq0,X_4\geq0,X_5\geq0,X_6\geq0</script>]]></content>
      <categories>
        <category>自我升华</category>
      </categories>
      <tags>
        <tag>运筹学</tag>
      </tags>
  </entry>
  <entry>
    <title>线性规划-1-数学模型</title>
    <url>/2019/07/10/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92-1-%E6%95%B0%E5%AD%A6%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>&#8195;&#8195;还记得大学的时候，学习过《运筹学》这门课，当时没什么感觉，乃至毕业工作之后的几年，没怎么用到，也慢慢淡忘了。感叹曾经的年少无知，随着工作时间的积累，越发觉得数学建模、运筹学、离散数学、统计学等等这些课程的重要性，仅仅会写if else，会用几个框架，我觉得是远远不够的。所以，业余抽点时间，在研究一下运筹学，不知道还能不能看得懂了。</p>
<p>&#8195;&#8195;其实生活中有很多运筹学的例子，一般的问题都可以用运筹学中的线性规划来解决；so，先从就基础的线性规划开始，首先先了解一下线性规划问题的数学模型。</p>
<p>&#8195;&#8195;线性规划是志在充分利用现有资源，最大限度完成目标，获得最高效益的有效工具。一般的，限行规划在实际生产中解决的问题有:</p>
<p>&#8195;&#8195;<em> 生产计划安排<br>&#8195;&#8195;</em> 配料问题<br>&#8195;&#8195;<em> 机组人员排班<br>&#8195;&#8195;</em> 等等😄</p>
<p>&#8195;&#8195;这个举个简单的配料问题的🌰，简单了解一下实际生活与线性规划的关系。</p>
<h4 id="eg"><a href="#eg" class="headerlink" title="eg"></a>eg</h4><p>&#8195;&#8195;一饲养场饲养供实验用的动物,已知动物生长对饲料中的三种营养成分—蛋白质、矿物质和维生素特别敏感。每个动物每天至少需要蛋白质70克,矿物质3克,维生素10毫克,该场能搞到三种饲料,每种饲料的成本，如下表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>饲料</th>
<th style="text-align:right">A1</th>
<th style="text-align:center">A2</th>
<th style="text-align:center">A3</th>
</tr>
</thead>
<tbody>
<tr>
<td>成本（元）</td>
<td style="text-align:right">2</td>
<td style="text-align:center">7</td>
<td style="text-align:center">4</td>
</tr>
</tbody>
</table>
</div>
<p>&#8195;&#8195;每一千克饲料中所含的营养成分，如下表,我们希望确定既能满足动物需要,又使成本最低的饲料配方。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>饲料</th>
<th style="text-align:right">蛋白质</th>
<th style="text-align:center">矿物质</th>
<th style="text-align:center">维生素</th>
</tr>
</thead>
<tbody>
<tr>
<td>A1</td>
<td style="text-align:right">0.3</td>
<td style="text-align:center">0.1</td>
<td style="text-align:center">0.05</td>
</tr>
<tr>
<td>A2</td>
<td style="text-align:right">2</td>
<td style="text-align:center">0.05</td>
<td style="text-align:center">0.1</td>
</tr>
<tr>
<td>A3</td>
<td style="text-align:right">1</td>
<td style="text-align:center">0.02</td>
<td style="text-align:center">0.02</td>
</tr>
</tbody>
</table>
</div>
<p>&#8195;&#8195;显然本题的目标是找到成本最低的配料方案，同时满足动物的营养。</p>
<h4 id="求解"><a href="#求解" class="headerlink" title="求解"></a>求解</h4><p>&#8195;&#8195;我们假设需要A1饲料 X<sub>1</sub>,需要A2饲料 X<sub>2</sub>,需要A3饲料 X<sub>3</sub>，那么根据第一个表，得出所需成本的表达式即 2<em>X<sub>1</sub> + 7</em>X<sub>2</sub> + 4*X<sub>3</sub>，那么最低成本即表示为</p>
<script type="math/tex; mode=display">Min \ \ \ \ 2*X_1 + 7*X_2 + 4*X_3</script><p>&#8195;&#8195;再根据动物每天至少需要蛋白质70克,矿物质3克,维生素10毫克，以及下边的表(竖着看)，可以得出约束条件如下：</p>
<script type="math/tex; mode=display">s.t. \ \ \ \ 0.3*X_1 + 2*X_2 + 1*X_3 \geq70\\
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ 0.1*X_1 + 0.05*X_2 + 0.02*X_3 \geq3\\
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ 0.05*X_1 + 0.1*X_2 + 0.02*X_3 \geq3\\
X_1\geq0,X_2\geq0,X_3\geq0</script><p>&#8195;&#8195;这就是一个配料问题，用线性规划的方式表达的数学模型。问题我们是用数学表达式的形式表示出来了，但是这个线性规划怎么求解呢？本篇文章先是初步认识，我也是逐步学习，容我缓缓，系列二再一起学习求解。😄</p>
<p>&#8195;&#8195;<font face="新宋体" color="“#aaaaaa”">本文样例来源于网络，我进行了稍微修改，原文链接</font>：<a href="https://blog.csdn.net/hhh_0820/article/details/71105246" target="_blank" rel="noopener">https://blog.csdn.net/hhh_0820/article/details/71105246</a></p>
]]></content>
      <categories>
        <category>自我升华</category>
      </categories>
      <tags>
        <tag>运筹学</tag>
      </tags>
  </entry>
  <entry>
    <title>2018年终总结</title>
    <url>/2019/02/02/2018%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>&#8195;&#8195;今天是2019年2月2号，农历腊月二十八，办公室里的同事已经寥寥无几，我还坚守在岗位上，我跟我媳妇戏言，是为了对得起我的敬业福啊，哈哈。转眼2018年就剩2天了，回顾过去一整年，我对自己的评价是不成功的。</p>
<h4 id="过去的2018"><a href="#过去的2018" class="headerlink" title="过去的2018"></a>过去的2018</h4><p>&#8195;&#8195;过去的一年，工作上对于我来说最大的事情，应该是换了个工作。在原来单位工作了6年，从一个最基层的程序员，做到了产品线经理，从技术和业务的积累上，基本上得到了上上下下的认可，年度优秀员工和年度优秀团队也都感受过。在个人情感上，6年的时间肯定有很多的感动和心酸在里边，谈不上爱，当然肯定没有恨，哈哈，只是在个人发展瓶颈和生活矛盾上难以处理，与其纠结，不如选择急流勇退。</p>
<p>&#8195;&#8195;这一年，在原单位，兼职过产品经理，做产品规划、产品定位、产品设计；兼职过需求和设计，写需求说明、画原型；兼职过架构师，规划系统架构、规划产品开发角色；兼职过开发经理，核心代码编写、系统开发管控；兼职过售前，ppt制作、产品宣讲、写标书；兼职过售后，运维沟通、邮件回复；做过产品线经理，产品线日常工作管理，其实就是汇报、审批的一些杂事。怎么样？是不是异常丰富？有的人会说，你可以啊，啥都能干啊。可是我觉得，说不好听就是有点不务正业，因为职位做得多，但是有限的时间内，是没办法做精的。当然，我还是要感谢能给我接触这么多事情的机会。</p>
<p>&#8195;&#8195;在新单位，由于来的时间并不长，虽然有相关的业务经验，但是每个公司在其日积月累的发展中，都会有其自己的独特性，所以在新单位的2018年总结中，工作相关我就不说太多了。但是比较让我庆幸的是，公司安排了有丰富工作经验，并且是今年年度优秀员工的老郭（此处应该有照片😄，带美颜那种）来带我，让我能够快速的学习到公司业务和了解公司相关情况，很是感谢。</p>
<h4 id="未来的2019"><a href="#未来的2019" class="headerlink" title="未来的2019"></a>未来的2019</h4><p>&#8195;&#8195;即将到来的2019年，是个怎样的一年，难以预测，资本寒冬是否会随着即将过去的2018年一样成为历史，还难以评定，所以，静观其变吧。不管怎样，新的一年应该有个新的气象，也学学当下流行的，立几个flag吧。</p>
<p>&#8195;&#8195;1、工作突破。自从参加工作以来，经历过的公司，我都力争做到公司里边各级领导和员工的认可，事实上，我也都做到了。所以，在新的单位，我有信心，同时我也做好了准备。</p>
<p>&#8195;&#8195;2、自我提升。所谓活到老，学到老,这是千古名训啊，不能忘。可能随着年龄的增长，或者是工作增多的原因，似乎变的越来越懒惰，这是非常不可取的。新的一年，技术业务和管理上，准备多读几本书，多做一些实践。</p>
<p>&#8195;&#8195;3、锻炼身体。身体越来越差了，体检好几个指标有问题，虽然问题不大，但是身体确实大不如前是事实。有时候上公交，挤不过老太太，真是挺尴尬啊。</p>
<p>&#8195;&#8195;4、来场旅游。跟我媳妇结婚一年多了，还没带她出去玩过。2019年，必须带她到除秦皇岛之外的其他地方，来一场说走就走的旅行。去他娘的没时间，去他娘的人民币，去她娘的那么多去她娘的…</p>
<p>&#8195;&#8195;5、生个孩子玩玩。此处省略一万字。</p>
<h4 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h4><p>&#8195;&#8195;过去的一年已经是历史，是好是坏也不能改变，新的一年，努力奔跑，只为追上曾经被家人寄予厚望的自己。</p>
<div align="center"><img src="http://img.tantuw.com/atachment/1710/1036452T7.jpg" alt></div>]]></content>
      <categories>
        <category>人生感悟</category>
      </categories>
      <tags>
        <tag>年终总结</tag>
      </tags>
  </entry>
  <entry>
    <title>趣学算法(2)--贪心算法</title>
    <url>/2019/02/02/%E8%B6%A3%E5%AD%A6%E7%AE%97%E6%B3%95-2-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>&#8195;&#8195;接着算法系列，今天说说贪心算法。贪心这词一般说起来，感觉是个贬义词。但是现实生活中，谁有没有点贪心呢？比如两个苹果让你选，甜度相同，长相相同的情况下，你肯定会先挑大的；菜市场买菜，两家菜完全一样，你肯定挑其中更便宜的；男女双方择偶标准，是美优先？还是富优先？还是学历优先？不管怎样，你心里肯定会先排个序。这些案例从不同角度不同层面展现了我们在日常生活中，解决问题的方式方法，不得不说，大千世界各种理论都是源于生活，然后又应用的生活中去的。贪心算法，基本也是这个意思，书上的解释是迭代求局部最优解，我的解释我觉得更通俗易懂，就是不停的矮子里拔将军，哈哈。</p>
<h3 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0-1背包问题"></a>0-1背包问题</h3><p>&#8195;&#8195;背包问题是比较经典的问题，由此演绎的版本也有很多，像什么海盗船装载问题，冒泡排序的理念和贪心算法也相似。这里就说一个最原始0-1背包问题。</p>
<p>&#8195;&#8195;<em>.问题描述:.</em> 假设有几个物品，其体积和价值如下表所示：<br>|    物品     | 物品一   |  物品二  | 物品三   |  物品四  | 物品五   |<br>| ———— |:——-:  | :——:  |:——:  |:——:  |——:  |<br>| 体积     | 6 |   7     |  4     |  3     |  10     |<br>| 价值        |   18   |   14   |  16     |  15     |  25     |</p>
<p>&#8195;&#8195;现在你有一个背包，可以容纳的最大体积是10，那么怎么装物品，会得到比较多的价值（所有物品不可分割）？</p>
<p>&#8195;&#8195;这是一道比较经典的0-1背包问题，背包问题的求解方法有很多，贪心、回溯、动态规划等等都可以解答，后续随着学习的深入，慢慢介绍，今天先说用贪心法求解。题目最后要求的结果是，获取比较多的价值，我们很容易想到按物品价值从高到低排序，依次取就行了呗，这算是一种价值贪心算法；题目中又说背包可容纳的最大体积是10，我们也很容易想到根据物品的体积从小到大排序，依次取，当然这也是一种贪心算法，体积优先；当然还可以用这两种算法折中的办法，单位体积优先，就是价值/体积的排序贪心算法，主要核心代码如下（本文代码地址<a href="https://github.com/wangpengda/algorithm/tree/master/Greedy" target="_blank" rel="noopener">https://github.com/wangpengda/algorithm/tree/master/Greedy</a>）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Model;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Goods</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Goods</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Goods</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Goods</span><span class="params">(<span class="keyword">double</span> size, <span class="keyword">double</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.Id = java.util.UUID.randomUUID().toString();</span><br><span class="line">        <span class="keyword">this</span>.Name = <span class="string">"都行"</span>;</span><br><span class="line">        <span class="keyword">this</span>.Size = size;</span><br><span class="line">        <span class="keyword">this</span>.Value = value;</span><br><span class="line">        <span class="keyword">this</span>.PerValue = value / size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String Id;<span class="comment">//唯一标识</span></span><br><span class="line">    <span class="keyword">private</span> String Name;<span class="comment">//没有实际意义</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> Size;<span class="comment">//体积</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> Value;<span class="comment">//价值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> PerValue;<span class="comment">//平均价值</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        Id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        Name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Size; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSize</span><span class="params">(<span class="keyword">double</span> size)</span> </span>&#123;</span><br><span class="line">        Size = size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">double</span> value)</span> </span>&#123;</span><br><span class="line">        Value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPerValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> PerValue; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPerValue</span><span class="params">(<span class="keyword">double</span> perValue)</span> </span>&#123; PerValue = perValue; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Goods g)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//按size排序</span></span><br><span class="line"><span class="comment">//        if (g.Size &gt;= this.Size) return -1;</span></span><br><span class="line"><span class="comment">//        else return 1;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//按平均价值排序</span></span><br><span class="line">        <span class="keyword">if</span> (g.PerValue &gt;= <span class="keyword">this</span>.PerValue) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#8195;&#8195;我们用贪心算法求解的这个问题，最后得到的结果是物品三、四，最终的价值是31，但是其实由于这道题的物品数量很少，直接用眼看也能看出来，最优解应该是物品一、三，最优价值是34。所以物品不可分割的0-1背包问题，用贪心算法有时候只能得到近似解，不一定能得到最优解。当然，现实生活中，有些问题并不要求一定得到最优解，那么选择贪心算法得到近似解的方法就可以考虑选用。</p>
<h3 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h3><p>&#8195;&#8195;记得上学的时候，学过一个经典的问题是最短路径问题，工作中也没怎么碰到过，当然如果有从事地图算法相关工作的同学，相信对于这个问题肯定不陌生。其实现实生活中，我们肯定遇到过类似的问题，比如国庆假期出去旅游，准备从北京出发，去济南、郑州、西安、拉萨、九寨这几个地方玩，要选择怎么样的路线比较好呢？我只是举个最短路径算法的例子，现实中，各位不差钱的大佬可能直接就来场说走就走的旅行就ok了，哈哈。</p>
<p>&#8195;&#8195;言归正传，这类问题用算法图的语言表述就是，给定有向带权图G=（V,E），每条边的权重非负数，给定V中的一个定点为源点，从源点出发，计算到所有其他点的最短路径长度。</p>
<p>&#8195;&#8195;解决这类问题，有个非常著名的算法，叫做Dijkstra（迪杰斯特拉）算法，记得数据结构一书中应该学过，不过当时应该算一脸懵逼，现在再回忆一下。Dijkstra算法是解决单元最短路径的贪心算法，先求出最短路径，再参照该路径求次短路径，直到求出源点到各点的所有最短路径。具体细节我在这就不详细赘述了，有兴趣的可以回去翻翻数据结构的书，或者网上查查具体逻辑，用java代码实现了一下，感兴趣可以组织组织数据结构，调一下算法试一下，核心代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Model.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">//迪杰斯特拉算法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dijkstra</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_DISTANCE = <span class="number">9999999</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DijResult <span class="title">Calculation</span><span class="params">(DijGraph g, String p)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; graphpoints = g.getPoints();</span><br><span class="line">        <span class="keyword">if</span> (!graphpoints.contains(p)) <span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">//判断是否是图中的点，不是即返回null</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] matrixG = g.getMatrixG();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span>[] checkflag = <span class="keyword">new</span> <span class="keyword">boolean</span>[graphpoints.size()];</span><br><span class="line">        String[] prev = <span class="keyword">new</span> String[graphpoints.size()];</span><br><span class="line">        <span class="keyword">int</span>[] dist = <span class="keyword">new</span> <span class="keyword">int</span>[graphpoints.size()];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> indexofp = graphpoints.indexOf(p);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; checkflag.length; i++) &#123;</span><br><span class="line">            checkflag[i] = <span class="keyword">false</span>;<span class="comment">//初始化检查数组</span></span><br><span class="line">            dist[i] = Math.min(MAX_DISTANCE, matrixG[indexofp][i]);<span class="comment">//初始化距离数组</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        checkflag[indexofp] = <span class="keyword">true</span>;<span class="comment">//初始化原点P对应的检查数据</span></span><br><span class="line">        dist[indexofp] = <span class="number">0</span>;<span class="comment">//初始化原点P对应的距离数组</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> nearindex = indexofp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graphpoints.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> min = MAX_DISTANCE;</span><br><span class="line">            <span class="comment">//在没有找过的剩下的点中，循环取距离当前点最近的点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; graphpoints.size(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (checkflag[j] == <span class="keyword">false</span> &amp;&amp; dist[j] &lt; min) &#123;</span><br><span class="line">                    min = dist[j];</span><br><span class="line">                    nearindex = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; graphpoints.size(); j++) &#123;</span><br><span class="line">                <span class="comment">//对比上一个节点 和 最短距离数组，更新数组</span></span><br><span class="line">                <span class="keyword">int</span> tmpdist = Math.min(MAX_DISTANCE, min + matrixG[nearindex][j]);</span><br><span class="line">                <span class="keyword">if</span> (checkflag[j] == <span class="keyword">false</span> &amp;&amp; tmpdist &lt; dist[j]) &#123;</span><br><span class="line">                    dist[j] = tmpdist;</span><br><span class="line">                    prev[j] = graphpoints.get(nearindex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DijResult(prev,dist);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h4><p>&#8195;&#8195;很多问题的方案都可以用到贪心算法，像书中提到的哈夫曼编码、最小生成树等，还有像磁盘存储、生产调度等等，都可以设计。贪心算法的优势是速度快，很明显，大家也能看出来，用当下的流行语描述下它的思想就是，“干就完了”，它不考虑大局，局部咔咔就是干；缺点也很明显，就是有时候算出来的并不是最优解，只能得到个近似解。</p>
<p>&#8195;&#8195;最近因为工作的原因，个人自身学习上抽不出太多时间，后续尽量争取能挤出时间，继续该系列的学习。</p>
<p><font face="新宋体" color="“#aaaaaa”">备注：期间个人博客增加了背景音乐、在线联系、Fork me等功能，欢迎来踩。另外，java的开发工具，从eclipse换成了idea，貌似确实体验比eclipse好一点，哈哈。生命不息，折腾不止。</font></p>
]]></content>
      <categories>
        <category>自我升华</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>趣学算法(1)--从Fibonacci说起</title>
    <url>/2018/12/20/%E8%B6%A3%E5%AD%A6%E7%AE%97%E6%B3%95-1-%E4%BB%8EFibonacci%E8%AF%B4%E8%B5%B7/</url>
    <content><![CDATA[<p>&#8195;&#8195;由于最近工作中，也可以说是个人爱好吧，涉及到一些算法的问题，个人归结起来觉得应该是NP-Hard问题，一时找不到好的解决方案。于是网上各种搜索，偶然翻到一本《趣学算法》的书，大致看了两眼，发现曾经学过的一些算法 像回溯、贪心等算法，由于长时间不用，也都忘记了。于是决定在工作之余，同时借助这本书的机会，再系统学习下算法，争取在学习过程中，能找到我那NP-Hard问题的解决方案。</p>
<p>&#8195;&#8195;抛砖引玉，先从一个程序员都非常熟悉的斐波那契数列算法说起，感受一下算法的趣味。说起斐波那契，程序员们应该都非常熟悉了，估计是曾经我们学习递归时候的重点案例吧，但是除了递归还有没有别的方法呢？或者说我们有没有考虑过，结果是算对了，但是背后的效率怎么样呢？</p>
<h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p>&#8195;&#8195;先从熟悉的递归方法说起：</p>
<p>&#8195;&#8195;斐波那契数列应该都知道，据说大自然很多现象也都是斐波那契数，有兴趣的可以去查查，这里就不多介绍了，概念说一下，用函数公式的方式表示，大概是这个意思：</p>
<script type="math/tex; mode=display">F_n=\begin{cases} 
        1, & n = 1\ or\ n = 2\\ 
        F_{n-1}+F_{n-2}, & n>2
    \end{cases}</script><p>递归算法代码最容易理解，就是反复迭代调用自己往下计算，代码基本和上述表达式一样，如下（本文章代码均用java编写，样例代码地址<a href="https://github.com/wangpengda/algorithm" target="_blank" rel="noopener">https://github.com/wangpengda/algorithm</a>):</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fib</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line"> 		 SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"YYYY/MM/dd HH:mm:ss.SSS"</span>);</span><br><span class="line">		 System.out.println(sdf.format(<span class="keyword">new</span> Date()));</span><br><span class="line">		 System.out.println(Fib1(<span class="number">40</span>));</span><br><span class="line">		 System.out.println(sdf.format(<span class="keyword">new</span> Date()));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Fib1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> Fib1(n - <span class="number">1</span>) + Fib1(n - <span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#8195;&#8195;这个很容易理解，但是不知道有没有人用这个算过F(50),我这8G内存，4核电脑是算了半天没算出来。再专业一点就是看一下它的时间复杂度，仔细分析会发现是指数增长的，往后算，每多算一个数，时间是翻倍的，它的时间复杂度是O(2^n);</p>
<h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><p>&#8195;&#8195;其实斐波那契归根结底还是个数列问题，就和我们高中学的等差数列、等比数列差不多，只是它是和用当前项的前两项表示的，我们只需要记录下前两项就可以了，而不用像递归算法那样，每次都去计算前两项，具体代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fib</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"YYYY/MM/dd HH:mm:ss.SSS"</span>);</span><br><span class="line"></span><br><span class="line">		System.out.println(sdf.format(<span class="keyword">new</span> Date()));</span><br><span class="line">		System.out.println(Fib2(<span class="number">48</span>));</span><br><span class="line">		System.out.println(sdf.format(<span class="keyword">new</span> Date()));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Fib2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">int</span> numsecond = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">int</span> numfirst = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">int</span> temp = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">				temp = numsecond + numfirst;</span><br><span class="line">				numfirst = numsecond;</span><br><span class="line">				numsecond = temp;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> numsecond;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#8195;&#8195;这个算法的时间复杂度是O(n),用这个算F(10000)基本也在1秒之内，就是这么神奇啊。按理说这个写法速度上已经是质的飞跃了，但是…</p>
<h4 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h4><p>&#8195;&#8195;书上简单提了一句，还可以把时间复杂度降到O(logn),不过没有详细赘述。好事者如我，本着不打破砂锅的程序员不是好厨师的原则，继续搜索。不得不说，确实有大师，用矩阵的方法，也是让我开了眼界啊，具体看下列表达式：</p>
<script type="math/tex; mode=display">\left(\begin{array}{c}
F_n \\ 
F_{n-1}
\end{array}\right)=\left(\begin{array}{c}
F_{n-1}+F_{n-2} \\ 
F_{n-1}
\end{array}\right)=\left(\begin{array}{c}
1*F_{n-1}+1*F_{n-2} \\ 
1*F_{n-1}+0*F_{n-2}
\end{array}\right)=\left(\begin{array}{cc}
    1 & 1 \\ 
    1 & 0
\end{array}\right)*\left(\begin{array}{c}
    F_{n-1} \\ 
    F_{n-2}
\end{array}\right)\\
=\left(\begin{array}{cc}
    1 & 1 \\ 
    1 & 0
\end{array}\right)^2*\left(\begin{array}{c}
    F_{n-2} \\ 
    F_{n-3}
\end{array}\right)......=\left(\begin{array}{cc}
    1 & 1 \\ 
    1 & 0
\end{array}\right)^{n-2}*\left(\begin{array}{c}
    F_2 \\ 
    F_1
\end{array}\right)</script><p>&#8195;&#8195;看着上述表达式，有什么感想？耳边曾经经常响起的大学课程无用论是否还在回荡？事实证明，学校的课程还是相当有用的啊，不懂矩阵的回去查查大学线性代数，😄 。回过头来再说斐波那契问题，上述表达式把数列问题就转换成了，计算一个2*2矩阵的n-2次幂的问题,幂运算就可以用二分法运算降低时间复杂度了，简单说一下大概思路，就比如算2的32次幂，最简单办法肯定是循环31次，用2挨个乘；二分法的意思就是2的32次幂 可以转换为 2的16次幂乘以2的16次幂，2的16次幂 还可以转换为 2的8次幂乘以2的8次幂，……，以此类推，大概循环5次即可算出最后结果。思路大概就是这么个思路，网上代码是用python实现的，python里有成熟的计算矩阵的函数，我自己用java实现了一下，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fib</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"YYYY/MM/dd HH:mm:ss.SSS"</span>);</span><br><span class="line"></span><br><span class="line">		System.out.println(sdf.format(<span class="keyword">new</span> Date()));</span><br><span class="line">		System.out.println(Fib3(<span class="number">48</span>));</span><br><span class="line">		System.out.println(sdf.format(<span class="keyword">new</span> Date()));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Fib3</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">int</span>[][] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">2</span>];<span class="comment">//用二维数组模拟2*2矩阵</span></span><br><span class="line">			a[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">			a[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">			a[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">			a[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">int</span>[][] temp = matricPow(a, n - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> temp[<span class="number">0</span>][<span class="number">0</span>] + temp[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//矩阵相乘计算 目前只支持2*2矩阵相乘</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] matricMulity(<span class="keyword">int</span>[][] a, <span class="keyword">int</span>[][] b) &#123;</span><br><span class="line">		<span class="keyword">int</span>[][] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">		result[<span class="number">0</span>][<span class="number">0</span>] = a[<span class="number">0</span>][<span class="number">0</span>] * b[<span class="number">0</span>][<span class="number">0</span>] + a[<span class="number">0</span>][<span class="number">1</span>] * b[<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">		result[<span class="number">0</span>][<span class="number">1</span>] = a[<span class="number">0</span>][<span class="number">0</span>] * b[<span class="number">0</span>][<span class="number">1</span>] + a[<span class="number">0</span>][<span class="number">1</span>] * b[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">		result[<span class="number">1</span>][<span class="number">0</span>] = a[<span class="number">1</span>][<span class="number">0</span>] * b[<span class="number">0</span>][<span class="number">0</span>] + a[<span class="number">1</span>][<span class="number">1</span>] * b[<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">		result[<span class="number">1</span>][<span class="number">1</span>] = a[<span class="number">1</span>][<span class="number">0</span>] * b[<span class="number">0</span>][<span class="number">1</span>] + a[<span class="number">1</span>][<span class="number">1</span>] * b[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2*2矩阵幂运算</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] matricPow(<span class="keyword">int</span>[][] a, <span class="keyword">int</span> n) &#123;</span><br><span class="line">		<span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[][] &#123; &#123; <span class="number">1</span>, <span class="number">1</span> &#125;, &#123; <span class="number">1</span>, <span class="number">0</span> &#125; &#125;;</span><br><span class="line">		<span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> a;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> matricPow(matricMulity(a, a), n / <span class="number">2</span>);</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> matricMulity(matricPow(matricMulity(a, a), (n - <span class="number">1</span>) / <span class="number">2</span>), a);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#8195;&#8195;n比较小的时候，方法二和方法三计算时间差不多，n特别大才能看出些效果，当n=1,000,000时，方法一就不考虑了，今年应该算不出来。方法二和方法三，计算时间如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2018</span>/<span class="number">12</span>/<span class="number">20</span> <span class="number">22</span>:<span class="number">38</span>:<span class="number">11.811</span></span><br><span class="line"><span class="number">1884755131</span></span><br><span class="line"><span class="number">2018</span>/<span class="number">12</span>/<span class="number">20</span> <span class="number">22</span>:<span class="number">38</span>:<span class="number">11.821</span></span><br><span class="line"></span><br><span class="line"><span class="number">2018</span>/<span class="number">12</span>/<span class="number">20</span> <span class="number">22</span>:<span class="number">38</span>:<span class="number">13.822</span></span><br><span class="line"><span class="number">1884755131</span></span><br><span class="line"><span class="number">2018</span>/<span class="number">12</span>/<span class="number">20</span> <span class="number">22</span>:<span class="number">38</span>:<span class="number">13.823</span></span><br></pre></td></tr></table></figure>
<p>&#8195;&#8195;两种方法计算第100万位基本还在毫秒级别，一般情况可能第二种方法就够用了，但是你不研究第三种方法，是体会不到第三种方法的乐趣的，呵呵~~~</p>
<p><font face="新宋体" color="“#aaaaaa”">备注：本文章中所有公式都是用markdown代码编写，不是图片，不是word。第一次用markdown，基本也是第一次用java写程序，生命在于折腾嘛。后续我再研究研究将github的博客打开评论，希望各位来拍砖。</font></p>
]]></content>
      <categories>
        <category>自我升华</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>新的起点</title>
    <url>/2018/12/19/%E6%96%B0%E7%9A%84%E8%B5%B7%E7%82%B9/</url>
    <content><![CDATA[<p>&#8195;&#8195;新公司入职正好一个月，记录一下。</p>
<p>&#8195;&#8195;从今天开始定期写博客，方方面面的，刚开始用markdown和github写博客，不太习惯，慢慢习惯。</p>
]]></content>
      <categories>
        <category>人生感悟</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
