<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Panda的blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wangpengda.github.io/"/>
  <updated>2020-03-29T08:46:20.578Z</updated>
  <id>http://wangpengda.github.io/</id>
  
  <author>
    <name>Panda Wang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>线性规划-2-单纯性解法</title>
    <link href="http://wangpengda.github.io/2020/03/27/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92-2-%E5%8D%95%E7%BA%AF%E6%80%A7%E8%A7%A3%E6%B3%95/"/>
    <id>http://wangpengda.github.io/2020/03/27/线性规划-2-单纯性解法/</id>
    <published>2020-03-27T09:44:16.000Z</published>
    <updated>2020-03-29T08:46:20.578Z</updated>
    
    <content type="html"><![CDATA[<p>&#8195;&#8195;系列1初步认识了线性规划的数学模型，这就和我们小学初中的时候解应用题一样，假设未知数，列方程，求解；那么类似于配料问题，我们建立了线性规划的数学模型，那么怎么求解呢？怎么算得到最优解呢？<br>&#8195;&#8195;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;#8195;&amp;#8195;系列1初步认识了线性规划的数学模型，这就和我们小学初中的时候解应用题一样，假设未知数，列方程，求解；那么类似于配料问题，我们建立了线性规划的数学模型，那么怎么求解呢？怎么算得到最优解呢？&lt;br&gt;&amp;#8195;&amp;#8195;&lt;/p&gt;

      
    
    </summary>
    
      <category term="自我升华" scheme="http://wangpengda.github.io/categories/%E8%87%AA%E6%88%91%E5%8D%87%E5%8D%8E/"/>
    
    
      <category term="运筹学" scheme="http://wangpengda.github.io/tags/%E8%BF%90%E7%AD%B9%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>线性规划-1-数学模型</title>
    <link href="http://wangpengda.github.io/2019/07/10/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92-1-%E6%95%B0%E5%AD%A6%E6%A8%A1%E5%9E%8B/"/>
    <id>http://wangpengda.github.io/2019/07/10/线性规划-1-数学模型/</id>
    <published>2019-07-10T03:49:51.000Z</published>
    <updated>2020-03-26T07:22:38.917Z</updated>
    
    <content type="html"><![CDATA[<p>&#8195;&#8195;还记得大学的时候，学习过《运筹学》这门课，当时没什么感觉，乃至毕业工作之后的几年，没怎么用到，也慢慢淡忘了。感叹曾经的年少无知，随着工作时间的积累，越发觉得数学建模、运筹学、离散数学、统计学等等这些课程的重要性，仅仅会写if else，会用几个框架，我觉得是远远不够的。所以，业余抽点时间，在研究一下运筹学，不知道还能不能看得懂了。</p><p>&#8195;&#8195;其实生活中有很多运筹学的例子，一般的问题都可以用运筹学中的线性规划来解决；so，先从就基础的线性规划开始，首先先了解一下线性规划问题的数学模型。</p><p>&#8195;&#8195;线性规划是志在充分利用现有资源，最大限度完成目标，获得最高效益的有效工具。一般的，限行规划在实际生产中解决的问题有:</p><p>&#8195;&#8195;<em> 生产计划安排<br>&#8195;&#8195;</em> 配料问题<br>&#8195;&#8195;<em> 机组人员排班<br>&#8195;&#8195;</em> 等等😄</p><p>&#8195;&#8195;这个举个简单的配料问题的🌰，简单了解一下实际生活与线性规划的关系。</p><h4 id="eg"><a href="#eg" class="headerlink" title="eg"></a>eg</h4><p>&#8195;&#8195;一饲养场饲养供实验用的动物,已知动物生长对饲料中的三种营养成分—蛋白质、矿物质和维生素特别敏感。每个动物每天至少需要蛋白质70克,矿物质3克,维生素10毫克,该场能搞到五种饲料,每种饲料的成本，如下表</p><div class="table-container"><table><thead><tr><th>饲料</th><th style="text-align:right">A1</th><th style="text-align:center">A2</th><th style="text-align:center">A3</th></tr></thead><tbody><tr><td>成本（元）</td><td style="text-align:right">2</td><td style="text-align:center">7</td><td style="text-align:center">4</td></tr></tbody></table></div><p>&#8195;&#8195;每一千克饲料中所含的营养成分，如下表,我们希望确定既能满足动物需要,又使成本最低的饲料配方。</p><div class="table-container"><table><thead><tr><th>饲料</th><th style="text-align:right">蛋白质</th><th style="text-align:center">矿物质</th><th style="text-align:center">维生素</th></tr></thead><tbody><tr><td>A1</td><td style="text-align:right">0.3</td><td style="text-align:center">0.1</td><td style="text-align:center">0.05</td></tr><tr><td>A2</td><td style="text-align:right">2</td><td style="text-align:center">0.05</td><td style="text-align:center">0.1</td></tr><tr><td>A3</td><td style="text-align:right">1</td><td style="text-align:center">0.02</td><td style="text-align:center">0.02</td></tr></tbody></table></div><p>&#8195;&#8195;显然本题的目标是找到成本最低的配料方案，同时满足动物的营养。</p><h4 id="求解"><a href="#求解" class="headerlink" title="求解"></a>求解</h4><p>&#8195;&#8195;我们假设需要A1饲料 X<sub>1</sub>,需要A2饲料 X<sub>2</sub>,需要A3饲料 X<sub>3</sub>，那么根据第一个表，得出所需成本的表达式即 2<em>X<sub>1</sub> + 7</em>X<sub>2</sub> + 4*X<sub>3</sub>，那么最低成本即表示为</p><script type="math/tex; mode=display">Min \ \ \ \ 2*X_1 + 7*X_2 + 4*X_3</script><p>&#8195;&#8195;再根据动物每天至少需要蛋白质70克,矿物质3克,维生素10毫克，以及下边的表(竖着看)，可以得出约束条件如下：</p><script type="math/tex; mode=display">s.t. \ \ \ \ 0.3*X_1 + 2*X_2 + 1*X_3 \geq70\\\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ 0.1*X_1 + 0.05*X_2 + 0.02*X_3 \geq3\\\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ 0.05*X_1 + 0.1*X_2 + 0.02*X_3 \geq3\\X_1\geq0,X_2\geq0,X_3\geq0</script><p>&#8195;&#8195;这就是一个配料问题，用线性规划的方式表达的数学模型。问题我们是用数学表达式的形式表示出来了，但是这个线性规划怎么求解呢？本篇文章先是初步认识，我也是逐步学习，容我缓缓，系列二再一起学习求解。😄</p><p>&#8195;&#8195;<font face="新宋体" color="“#aaaaaa”">本文样例来源于网络，我进行了稍微修改，原文链接</font>：<a href="https://blog.csdn.net/hhh_0820/article/details/71105246" target="_blank" rel="noopener">https://blog.csdn.net/hhh_0820/article/details/71105246</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;#8195;&amp;#8195;还记得大学的时候，学习过《运筹学》这门课，当时没什么感觉，乃至毕业工作之后的几年，没怎么用到，也慢慢淡忘了。感叹曾经的年少无知，随着工作时间的积累，越发觉得数学建模、运筹学、离散数学、统计学等等这些课程的重要性，仅仅会写if else，会用几个框
      
    
    </summary>
    
      <category term="自我升华" scheme="http://wangpengda.github.io/categories/%E8%87%AA%E6%88%91%E5%8D%87%E5%8D%8E/"/>
    
    
      <category term="运筹学" scheme="http://wangpengda.github.io/tags/%E8%BF%90%E7%AD%B9%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>2018年终总结</title>
    <link href="http://wangpengda.github.io/2019/02/02/2018%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    <id>http://wangpengda.github.io/2019/02/02/2018年终总结/</id>
    <published>2019-02-02T09:14:08.000Z</published>
    <updated>2019-02-02T13:47:22.811Z</updated>
    
    <content type="html"><![CDATA[<p>&#8195;&#8195;今天是2019年2月2号，农历腊月二十八，办公室里的同事已经寥寥无几，我还坚守在岗位上，我跟我媳妇戏言，是为了对得起我的敬业福啊，哈哈。转眼2018年就剩2天了，回顾过去一整年，我对自己的评价是不成功的。</p><h4 id="过去的2018"><a href="#过去的2018" class="headerlink" title="过去的2018"></a>过去的2018</h4><p>&#8195;&#8195;过去的一年，工作上对于我来说最大的事情，应该是换了个工作。在原来单位工作了6年，从一个最基层的程序员，做到了产品线经理，从技术和业务的积累上，基本上得到了上上下下的认可，年度优秀员工和年度优秀团队也都感受过。在个人情感上，6年的时间肯定有很多的感动和心酸在里边，谈不上爱，当然肯定没有恨，哈哈，只是在个人发展瓶颈和生活矛盾上难以处理，与其纠结，不如选择急流勇退。</p><p>&#8195;&#8195;这一年，在原单位，兼职过产品经理，做产品规划、产品定位、产品设计；兼职过需求和设计，写需求说明、画原型；兼职过架构师，规划系统架构、规划产品开发角色；兼职过开发经理，核心代码编写、系统开发管控；兼职过售前，ppt制作、产品宣讲、写标书；兼职过售后，运维沟通、邮件回复；做过产品线经理，产品线日常工作管理，其实就是汇报、审批的一些杂事。怎么样？是不是异常丰富？有的人会说，你可以啊，啥都能干啊。可是我觉得，说不好听就是有点不务正业，因为职位做得多，但是有限的时间内，是没办法做精的。当然，我还是要感谢能给我接触这么多事情的机会。</p><p>&#8195;&#8195;在新单位，由于来的时间并不长，虽然有相关的业务经验，但是每个公司在其日积月累的发展中，都会有其自己的独特性，所以在新单位的2018年总结中，工作相关我就不说太多了。但是比较让我庆幸的是，公司安排了有丰富工作经验，并且是今年年度优秀员工的老郭（此处应该有照片😄，带美颜那种）来带我，让我能够快速的学习到公司业务和了解公司相关情况，很是感谢。</p><h4 id="未来的2019"><a href="#未来的2019" class="headerlink" title="未来的2019"></a>未来的2019</h4><p>&#8195;&#8195;即将到来的2019年，是个怎样的一年，难以预测，资本寒冬是否会随着即将过去的2018年一样成为历史，还难以评定，所以，静观其变吧。不管怎样，新的一年应该有个新的气象，也学学当下流行的，立几个flag吧。</p><p>&#8195;&#8195;1、工作突破。自从参加工作以来，经历过的公司，我都力争做到公司里边各级领导和员工的认可，事实上，我也都做到了。所以，在新的单位，我有信心，同时我也做好了准备。</p><p>&#8195;&#8195;2、自我提升。所谓活到老，学到老,这是千古名训啊，不能忘。可能随着年龄的增长，或者是工作增多的原因，似乎变的越来越懒惰，这是非常不可取的。新的一年，技术业务和管理上，准备多读几本书，多做一些实践。</p><p>&#8195;&#8195;3、锻炼身体。身体越来越差了，体检好几个指标有问题，虽然问题不大，但是身体确实大不如前是事实。有时候上公交，挤不过老太太，真是挺尴尬啊。</p><p>&#8195;&#8195;4、来场旅游。跟我媳妇结婚一年多了，还没带她出去玩过。2019年，必须带她到除秦皇岛之外的其他地方，来一场说走就走的旅行。去他娘的没时间，去他娘的人民币，去她娘的那么多去她娘的…</p><p>&#8195;&#8195;5、生个孩子玩玩。此处省略一万字。</p><h4 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h4><p>&#8195;&#8195;过去的一年已经是历史，是好是坏也不能改变，新的一年，努力奔跑，只为追上曾经被家人寄予厚望的自己。</p><div align="center"><img src="http://img.tantuw.com/atachment/1710/1036452T7.jpg" alt></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;#8195;&amp;#8195;今天是2019年2月2号，农历腊月二十八，办公室里的同事已经寥寥无几，我还坚守在岗位上，我跟我媳妇戏言，是为了对得起我的敬业福啊，哈哈。转眼2018年就剩2天了，回顾过去一整年，我对自己的评价是不成功的。&lt;/p&gt;
&lt;h4 id=&quot;过去的2018&quot;
      
    
    </summary>
    
      <category term="人生感悟" scheme="http://wangpengda.github.io/categories/%E4%BA%BA%E7%94%9F%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="年终总结" scheme="http://wangpengda.github.io/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>趣学算法(2)--贪心算法</title>
    <link href="http://wangpengda.github.io/2019/02/02/%E8%B6%A3%E5%AD%A6%E7%AE%97%E6%B3%95-2-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    <id>http://wangpengda.github.io/2019/02/02/趣学算法-2-贪心算法/</id>
    <published>2019-02-02T06:37:27.000Z</published>
    <updated>2020-03-29T07:55:35.426Z</updated>
    
    <content type="html"><![CDATA[<p>&#8195;&#8195;接着算法系列，今天说说贪心算法。贪心这词一般说起来，感觉是个贬义词。但是现实生活中，谁有没有点贪心呢？比如两个苹果让你选，甜度相同，长相相同的情况下，你肯定会先挑大的；菜市场买菜，两家菜完全一样，你肯定挑其中更便宜的；男女双方择偶标准，是美优先？还是富优先？还是学历优先？不管怎样，你心里肯定会先排个序。这些案例从不同角度不同层面展现了我们在日常生活中，解决问题的方式方法，不得不说，大千世界各种理论都是源于生活，然后又应用的生活中去的。贪心算法，基本也是这个意思，书上的解释是迭代求局部最优解，我的解释我觉得更通俗易懂，就是不停的矮子里拔将军，哈哈。</p><h3 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0-1背包问题"></a>0-1背包问题</h3><p>&#8195;&#8195;背包问题是比较经典的问题，由此演绎的版本也有很多，像什么海盗船装载问题，冒泡排序的理念和贪心算法也相似。这里就说一个最原始0-1背包问题。</p><p>&#8195;&#8195;<em>.问题描述:.</em> 假设有几个物品，其体积和价值如下表所示：<br>|    物品     | 物品一   |  物品二  | 物品三   |  物品四  | 物品五   |<br>| ————   | ——-:  | :——:  |:——:  |:——:  |:——:  |<br>| 体积     | 6 |   7     |  4     |  3     |  10     |<br>| 价值        |   18   |   14   |  16     |  15     |  25     |</p><p>&#8195;&#8195;现在你有一个背包，可以容纳的最大体积是10，那么怎么装物品，会得到比较多的价值（所有物品不可分割）？</p><p>&#8195;&#8195;这是一道比较经典的0-1背包问题，背包问题的求解方法有很多，贪心、回溯、动态规划等等都可以解答，后续随着学习的深入，慢慢介绍，今天先说用贪心法求解。题目最后要求的结果是，获取比较多的价值，我们很容易想到按物品价值从高到低排序，依次取就行了呗，这算是一种价值贪心算法；题目中又说背包可容纳的最大体积是10，我们也很容易想到根据物品的体积从小到大排序，依次取，当然这也是一种贪心算法，体积优先；当然还可以用这两种算法折中的办法，单位体积优先，就是价值/体积的排序贪心算法，主要核心代码如下（本文代码地址<a href="https://github.com/wangpengda/algorithm/tree/master/Greedy" target="_blank" rel="noopener">https://github.com/wangpengda/algorithm/tree/master/Greedy</a>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Model;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Goods</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Goods</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Goods</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Goods</span><span class="params">(<span class="keyword">double</span> size, <span class="keyword">double</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.Id = java.util.UUID.randomUUID().toString();</span><br><span class="line">        <span class="keyword">this</span>.Name = <span class="string">"都行"</span>;</span><br><span class="line">        <span class="keyword">this</span>.Size = size;</span><br><span class="line">        <span class="keyword">this</span>.Value = value;</span><br><span class="line">        <span class="keyword">this</span>.PerValue = value / size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String Id;<span class="comment">//唯一标识</span></span><br><span class="line">    <span class="keyword">private</span> String Name;<span class="comment">//没有实际意义</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> Size;<span class="comment">//体积</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> Value;<span class="comment">//价值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> PerValue;<span class="comment">//平均价值</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        Id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        Name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Size; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSize</span><span class="params">(<span class="keyword">double</span> size)</span> </span>&#123;</span><br><span class="line">        Size = size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">double</span> value)</span> </span>&#123;</span><br><span class="line">        Value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPerValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> PerValue; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPerValue</span><span class="params">(<span class="keyword">double</span> perValue)</span> </span>&#123; PerValue = perValue; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Goods g)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//按size排序</span></span><br><span class="line"><span class="comment">//        if (g.Size &gt;= this.Size) return -1;</span></span><br><span class="line"><span class="comment">//        else return 1;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//按平均价值排序</span></span><br><span class="line">        <span class="keyword">if</span> (g.PerValue &gt;= <span class="keyword">this</span>.PerValue) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#8195;&#8195;我们用贪心算法求解的这个问题，最后得到的结果是物品三、四，最终的价值是31，但是其实由于这道题的物品数量很少，直接用眼看也能看出来，最优解应该是物品一、三，最优价值是34。所以物品不可分割的0-1背包问题，用贪心算法有时候只能得到近似解，不一定能得到最优解。当然，现实生活中，有些问题并不要求一定得到最优解，那么选择贪心算法得到近似解的方法就可以考虑选用。</p><h3 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h3><p>&#8195;&#8195;记得上学的时候，学过一个经典的问题是最短路径问题，工作中也没怎么碰到过，当然如果有从事地图算法相关工作的同学，相信对于这个问题肯定不陌生。其实现实生活中，我们肯定遇到过类似的问题，比如国庆假期出去旅游，准备从北京出发，去济南、郑州、西安、拉萨、九寨这几个地方玩，要选择怎么样的路线比较好呢？我只是举个最短路径算法的例子，现实中，各位不差钱的大佬可能直接就来场说走就走的旅行就ok了，哈哈。</p><p>&#8195;&#8195;言归正传，这类问题用算法图的语言表述就是，给定有向带权图G=（V,E），每条边的权重非负数，给定V中的一个定点为源点，从源点出发，计算到所有其他点的最短路径长度。</p><p>&#8195;&#8195;解决这类问题，有个非常著名的算法，叫做Dijkstra（迪杰斯特拉）算法，记得数据结构一书中应该学过，不过当时应该算一脸懵逼，现在再回忆一下。Dijkstra算法是解决单元最短路径的贪心算法，先求出最短路径，再参照该路径求次短路径，直到求出源点到各点的所有最短路径。具体细节我在这就不详细赘述了，有兴趣的可以回去翻翻数据结构的书，或者网上查查具体逻辑，用java代码实现了一下，感兴趣可以组织组织数据结构，调一下算法试一下，核心代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Model.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">//迪杰斯特拉算法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dijkstra</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_DISTANCE = <span class="number">9999999</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DijResult <span class="title">Calculation</span><span class="params">(DijGraph g, String p)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; graphpoints = g.getPoints();</span><br><span class="line">        <span class="keyword">if</span> (!graphpoints.contains(p)) <span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">//判断是否是图中的点，不是即返回null</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] matrixG = g.getMatrixG();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span>[] checkflag = <span class="keyword">new</span> <span class="keyword">boolean</span>[graphpoints.size()];</span><br><span class="line">        String[] prev = <span class="keyword">new</span> String[graphpoints.size()];</span><br><span class="line">        <span class="keyword">int</span>[] dist = <span class="keyword">new</span> <span class="keyword">int</span>[graphpoints.size()];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> indexofp = graphpoints.indexOf(p);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; checkflag.length; i++) &#123;</span><br><span class="line">            checkflag[i] = <span class="keyword">false</span>;<span class="comment">//初始化检查数组</span></span><br><span class="line">            dist[i] = Math.min(MAX_DISTANCE, matrixG[indexofp][i]);<span class="comment">//初始化距离数组</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        checkflag[indexofp] = <span class="keyword">true</span>;<span class="comment">//初始化原点P对应的检查数据</span></span><br><span class="line">        dist[indexofp] = <span class="number">0</span>;<span class="comment">//初始化原点P对应的距离数组</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> nearindex = indexofp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graphpoints.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> min = MAX_DISTANCE;</span><br><span class="line">            <span class="comment">//在没有找过的剩下的点中，循环取距离当前点最近的点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; graphpoints.size(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (checkflag[j] == <span class="keyword">false</span> &amp;&amp; dist[j] &lt; min) &#123;</span><br><span class="line">                    min = dist[j];</span><br><span class="line">                    nearindex = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; graphpoints.size(); j++) &#123;</span><br><span class="line">                <span class="comment">//对比上一个节点 和 最短距离数组，更新数组</span></span><br><span class="line">                <span class="keyword">int</span> tmpdist = Math.min(MAX_DISTANCE, min + matrixG[nearindex][j]);</span><br><span class="line">                <span class="keyword">if</span> (checkflag[j] == <span class="keyword">false</span> &amp;&amp; tmpdist &lt; dist[j]) &#123;</span><br><span class="line">                    dist[j] = tmpdist;</span><br><span class="line">                    prev[j] = graphpoints.get(nearindex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DijResult(prev,dist);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h4><p>&#8195;&#8195;很多问题的方案都可以用到贪心算法，像书中提到的哈夫曼编码、最小生成树等，还有像磁盘存储、生产调度等等，都可以设计。贪心算法的优势是速度快，很明显，大家也能看出来，用当下的流行语描述下它的思想就是，“干就完了”，它不考虑大局，局部咔咔就是干；缺点也很明显，就是有时候算出来的并不是最优解，只能得到个近似解。</p><p>&#8195;&#8195;最近因为工作的原因，个人自身学习上抽不出太多时间，后续尽量争取能挤出时间，继续该系列的学习。</p><p><font face="新宋体" color="“#aaaaaa”">备注：期间个人博客增加了背景音乐、在线联系、Fork me等功能，欢迎来踩。另外，java的开发工具，从eclipse换成了idea，貌似确实体验比eclipse好一点，哈哈。生命不息，折腾不止。</font></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;#8195;&amp;#8195;接着算法系列，今天说说贪心算法。贪心这词一般说起来，感觉是个贬义词。但是现实生活中，谁有没有点贪心呢？比如两个苹果让你选，甜度相同，长相相同的情况下，你肯定会先挑大的；菜市场买菜，两家菜完全一样，你肯定挑其中更便宜的；男女双方择偶标准，是美优先？
      
    
    </summary>
    
      <category term="自我升华" scheme="http://wangpengda.github.io/categories/%E8%87%AA%E6%88%91%E5%8D%87%E5%8D%8E/"/>
    
    
      <category term="算法" scheme="http://wangpengda.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>趣学算法(1)--从Fibonacci说起</title>
    <link href="http://wangpengda.github.io/2018/12/20/%E8%B6%A3%E5%AD%A6%E7%AE%97%E6%B3%95-1-%E4%BB%8EFibonacci%E8%AF%B4%E8%B5%B7/"/>
    <id>http://wangpengda.github.io/2018/12/20/趣学算法-1-从Fibonacci说起/</id>
    <published>2018-12-20T02:57:51.000Z</published>
    <updated>2018-12-26T09:55:51.402Z</updated>
    
    <content type="html"><![CDATA[<p>&#8195;&#8195;由于最近工作中，也可以说是个人爱好吧，涉及到一些算法的问题，个人归结起来觉得应该是NP-Hard问题，一时找不到好的解决方案。于是网上各种搜索，偶然翻到一本《趣学算法》的书，大致看了两眼，发现曾经学过的一些算法 像回溯、贪心等算法，由于长时间不用，也都忘记了。于是决定在工作之余，同时借助这本书的机会，再系统学习下算法，争取在学习过程中，能找到我那NP-Hard问题的解决方案。</p><p>&#8195;&#8195;抛砖引玉，先从一个程序员都非常熟悉的斐波那契数列算法说起，感受一下算法的趣味。说起斐波那契，程序员们应该都非常熟悉了，估计是曾经我们学习递归时候的重点案例吧，但是除了递归还有没有别的方法呢？或者说我们有没有考虑过，结果是算对了，但是背后的效率怎么样呢？</p><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p>&#8195;&#8195;先从熟悉的递归方法说起：</p><p>&#8195;&#8195;斐波那契数列应该都知道，据说大自然很多现象也都是斐波那契数，有兴趣的可以去查查，这里就不多介绍了，概念说一下，用函数公式的方式表示，大概是这个意思：</p><script type="math/tex; mode=display">F_n=\begin{cases}         1, & n = 1\ or\ n = 2\\         F_{n-1}+F_{n-2}, & n>2    \end{cases}</script><p>递归算法代码最容易理解，就是反复迭代调用自己往下计算，代码基本和上述表达式一样，如下（本文章代码均用java编写，样例代码地址<a href="https://github.com/wangpengda/algorithm" target="_blank" rel="noopener">https://github.com/wangpengda/algorithm</a>):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fib</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">  SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"YYYY/MM/dd HH:mm:ss.SSS"</span>);</span><br><span class="line"> System.out.println(sdf.format(<span class="keyword">new</span> Date()));</span><br><span class="line"> System.out.println(Fib1(<span class="number">40</span>));</span><br><span class="line"> System.out.println(sdf.format(<span class="keyword">new</span> Date()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Fib1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> Fib1(n - <span class="number">1</span>) + Fib1(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#8195;&#8195;这个很容易理解，但是不知道有没有人用这个算过F(50),我这8G内存，4核电脑是算了半天没算出来。再专业一点就是看一下它的时间复杂度，仔细分析会发现是指数增长的，往后算，每多算一个数，时间是翻倍的，它的时间复杂度是O(2^n);</p><h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><p>&#8195;&#8195;其实斐波那契归根结底还是个数列问题，就和我们高中学的等差数列、等比数列差不多，只是它是和用当前项的前两项表示的，我们只需要记录下前两项就可以了，而不用像递归算法那样，每次都去计算前两项，具体代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fib</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"YYYY/MM/dd HH:mm:ss.SSS"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(sdf.format(<span class="keyword">new</span> Date()));</span><br><span class="line">System.out.println(Fib2(<span class="number">48</span>));</span><br><span class="line">System.out.println(sdf.format(<span class="keyword">new</span> Date()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Fib2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> numsecond = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> numfirst = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> temp = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">temp = numsecond + numfirst;</span><br><span class="line">numfirst = numsecond;</span><br><span class="line">numsecond = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> numsecond;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#8195;&#8195;这个算法的时间复杂度是O(n),用这个算F(10000)基本也在1秒之内，就是这么神奇啊。按理说这个写法速度上已经是质的飞跃了，但是…</p><h4 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h4><p>&#8195;&#8195;书上简单提了一句，还可以把时间复杂度降到O(logn),不过没有详细赘述。好事者如我，本着不打破砂锅的程序员不是好厨师的原则，继续搜索。不得不说，确实有大师，用矩阵的方法，也是让我开了眼界啊，具体看下列表达式：</p><script type="math/tex; mode=display">\left(\begin{array}{c}F_n \\ F_{n-1}\end{array}\right)=\left(\begin{array}{c}F_{n-1}+F_{n-2} \\ F_{n-1}\end{array}\right)=\left(\begin{array}{c}1*F_{n-1}+1*F_{n-2} \\ 1*F_{n-1}+0*F_{n-2}\end{array}\right)=\left(\begin{array}{cc}    1 & 1 \\     1 & 0\end{array}\right)*\left(\begin{array}{c}    F_{n-1} \\     F_{n-2}\end{array}\right)\\=\left(\begin{array}{cc}    1 & 1 \\     1 & 0\end{array}\right)^2*\left(\begin{array}{c}    F_{n-2} \\     F_{n-3}\end{array}\right)......=\left(\begin{array}{cc}    1 & 1 \\     1 & 0\end{array}\right)^{n-2}*\left(\begin{array}{c}    F_2 \\     F_1\end{array}\right)</script><p>&#8195;&#8195;看着上述表达式，有什么感想？耳边曾经经常响起的大学课程无用论是否还在回荡？事实证明，学校的课程还是相当有用的啊，不懂矩阵的回去查查大学线性代数，😄 。回过头来再说斐波那契问题，上述表达式把数列问题就转换成了，计算一个2*2矩阵的n-2次幂的问题,幂运算就可以用二分法运算降低时间复杂度了，简单说一下大概思路，就比如算2的32次幂，最简单办法肯定是循环31次，用2挨个乘；二分法的意思就是2的32次幂 可以转换为 2的16次幂乘以2的16次幂，2的16次幂 还可以转换为 2的8次幂乘以2的8次幂，……，以此类推，大概循环5次即可算出最后结果。思路大概就是这么个思路，网上代码是用python实现的，python里有成熟的计算矩阵的函数，我自己用java实现了一下，具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fib</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"YYYY/MM/dd HH:mm:ss.SSS"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(sdf.format(<span class="keyword">new</span> Date()));</span><br><span class="line">System.out.println(Fib3(<span class="number">48</span>));</span><br><span class="line">System.out.println(sdf.format(<span class="keyword">new</span> Date()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Fib3</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span>[][] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">2</span>];<span class="comment">//用二维数组模拟2*2矩阵</span></span><br><span class="line">a[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">a[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">a[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">a[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[][] temp = matricPow(a, n - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> temp[<span class="number">0</span>][<span class="number">0</span>] + temp[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//矩阵相乘计算 目前只支持2*2矩阵相乘</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] matricMulity(<span class="keyword">int</span>[][] a, <span class="keyword">int</span>[][] b) &#123;</span><br><span class="line"><span class="keyword">int</span>[][] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">result[<span class="number">0</span>][<span class="number">0</span>] = a[<span class="number">0</span>][<span class="number">0</span>] * b[<span class="number">0</span>][<span class="number">0</span>] + a[<span class="number">0</span>][<span class="number">1</span>] * b[<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">result[<span class="number">0</span>][<span class="number">1</span>] = a[<span class="number">0</span>][<span class="number">0</span>] * b[<span class="number">0</span>][<span class="number">1</span>] + a[<span class="number">0</span>][<span class="number">1</span>] * b[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">result[<span class="number">1</span>][<span class="number">0</span>] = a[<span class="number">1</span>][<span class="number">0</span>] * b[<span class="number">0</span>][<span class="number">0</span>] + a[<span class="number">1</span>][<span class="number">1</span>] * b[<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">result[<span class="number">1</span>][<span class="number">1</span>] = a[<span class="number">1</span>][<span class="number">0</span>] * b[<span class="number">0</span>][<span class="number">1</span>] + a[<span class="number">1</span>][<span class="number">1</span>] * b[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2*2矩阵幂运算</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] matricPow(<span class="keyword">int</span>[][] a, <span class="keyword">int</span> n) &#123;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[][] &#123; &#123; <span class="number">1</span>, <span class="number">1</span> &#125;, &#123; <span class="number">1</span>, <span class="number">0</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> matricPow(matricMulity(a, a), n / <span class="number">2</span>);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> matricMulity(matricPow(matricMulity(a, a), (n - <span class="number">1</span>) / <span class="number">2</span>), a);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#8195;&#8195;n比较小的时候，方法二和方法三计算时间差不多，n特别大才能看出些效果，当n=1,000,000时，方法一就不考虑了，今年应该算不出来。方法二和方法三，计算时间如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2018</span>/<span class="number">12</span>/<span class="number">20</span> <span class="number">22</span>:<span class="number">38</span>:<span class="number">11.811</span></span><br><span class="line"><span class="number">1884755131</span></span><br><span class="line"><span class="number">2018</span>/<span class="number">12</span>/<span class="number">20</span> <span class="number">22</span>:<span class="number">38</span>:<span class="number">11.821</span></span><br><span class="line"></span><br><span class="line"><span class="number">2018</span>/<span class="number">12</span>/<span class="number">20</span> <span class="number">22</span>:<span class="number">38</span>:<span class="number">13.822</span></span><br><span class="line"><span class="number">1884755131</span></span><br><span class="line"><span class="number">2018</span>/<span class="number">12</span>/<span class="number">20</span> <span class="number">22</span>:<span class="number">38</span>:<span class="number">13.823</span></span><br></pre></td></tr></table></figure><p>&#8195;&#8195;两种方法计算第100万位基本还在毫秒级别，一般情况可能第二种方法就够用了，但是你不研究第三种方法，是体会不到第三种方法的乐趣的，呵呵~~~</p><p><font face="新宋体" color="“#aaaaaa”">备注：本文章中所有公式都是用markdown代码编写，不是图片，不是word。第一次用markdown，基本也是第一次用java写程序，生命在于折腾嘛。后续我再研究研究将github的博客打开评论，希望各位来拍砖。</font></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;#8195;&amp;#8195;由于最近工作中，也可以说是个人爱好吧，涉及到一些算法的问题，个人归结起来觉得应该是NP-Hard问题，一时找不到好的解决方案。于是网上各种搜索，偶然翻到一本《趣学算法》的书，大致看了两眼，发现曾经学过的一些算法 像回溯、贪心等算法，由于长时间不用
      
    
    </summary>
    
      <category term="自我升华" scheme="http://wangpengda.github.io/categories/%E8%87%AA%E6%88%91%E5%8D%87%E5%8D%8E/"/>
    
    
      <category term="算法" scheme="http://wangpengda.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>新的起点</title>
    <link href="http://wangpengda.github.io/2018/12/19/%E6%96%B0%E7%9A%84%E8%B5%B7%E7%82%B9/"/>
    <id>http://wangpengda.github.io/2018/12/19/新的起点/</id>
    <published>2018-12-19T06:46:56.000Z</published>
    <updated>2018-12-22T10:13:02.974Z</updated>
    
    <content type="html"><![CDATA[<p>&#8195;&#8195;新公司入职正好一个月，记录一下。</p><p>&#8195;&#8195;从今天开始定期写博客，方方面面的，刚开始用markdown和github写博客，不太习惯，慢慢习惯。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;#8195;&amp;#8195;新公司入职正好一个月，记录一下。&lt;/p&gt;
&lt;p&gt;&amp;#8195;&amp;#8195;从今天开始定期写博客，方方面面的，刚开始用markdown和github写博客，不太习惯，慢慢习惯。&lt;/p&gt;

      
    
    </summary>
    
      <category term="人生感悟" scheme="http://wangpengda.github.io/categories/%E4%BA%BA%E7%94%9F%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="随笔" scheme="http://wangpengda.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
